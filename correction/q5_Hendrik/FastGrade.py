# -*- coding: utf-8 -*-
"""
Created on Wed Sep 13 10:23:57 2017
Written and tested under WinPython-64bit-3.4.4.6 with PyQt5

@author: Nicholas LeBow
@contributions: Tinri Aegerter, Aleksejs Fomins

Requires files to be present in the same folder:
    FastGrade.ui            :    Graphical interface definition.
    <analysis_module>.py    :    Name specified in FastGradeEngine.__init__(); Per-exam analysis script for student files.

Generates/overwrites files in the same folder:
    state.pkl                :    Internal state data, stores user settings from last session.
    student_data.pkl        :    Imported student data
"""
__version__ = '2.6'
__author__ = 'Nicholas LeBow'

import builtins
import csv
import functools  # for dynamic signalling in dynamically generated interactive lists
import glob  # for filesystem IO, file searching/matching
import importlib.machinery  # to load function from gradescale file
import os
import pickle
import platform
import random
import re
import uuid # for generating id strings for comments.
import sys
import subprocess # to execute student code. Standard library replacement for easyprocess.
from collections import namedtuple, defaultdict
from operator import attrgetter
from PyQt5 import uic, QtCore
from PyQt5.Qt import QT_VERSION_STR, PYQT_VERSION_STR
from PyQt5.QtCore import Qt, QRegExp, QThread, pyqtSignal
from PyQt5.QtGui import QRegExpValidator, QPixmap, QColor, QTextCharFormat, QFont, QSyntaxHighlighter, QKeySequence
from PyQt5.QtWidgets import QFileDialog, QListWidgetItem, QMessageBox, QApplication, QLabel, QMainWindow, QCheckBox, \
    QSizePolicy, QShortcut

# Redefine default exception hook so PyQt passes exceptions up (otherwise no tracebacks displayed, just an exit code).
old_excepthook = sys.excepthook
def new_excepthook(exctype, value, traceback):
    """ Prints any exceptions caught before passing them to the default exception hook """
    print(exctype, value, traceback)
    old_excepthook(exctype, value, traceback)
    sys.exit(1)
sys.excepthook = new_excepthook

ui_file = 'FastGrade.ui'  # GUI definition file. Must be present in the same directory as the main script.
Ui_MainWindow, QtBaseClass = uic.loadUiType(ui_file) # binding to layout definition file

# STUDENT POINTS (QUESTION AND TOTAL) ARE RECALCULATED AT EVERY USE to avoid problems with importing/merging different files!
CommentTuple = namedtuple('CommentTuple', ['comment_id', 'question', 'points', 'comment_string'])


class Student:
    """
     Container class for data associated with a student.
     Use to build a sortable list representation of student data contained in a folder structure.
     Contains two sorts of comment lists, _comment_list and _alternative_comment_list. The alternative
     comment list is constructed to be able to directly compare different exam corrections (via
     selection tab, Comment difference with ACQ file).
     """
    def __init__(self, mat_nr='unknown', name='unknown', path=None, folder=None,
                 script_files=None, script_codes=None, script_outputs=None, script_plots=None):
        self.mat_nr = mat_nr; """ Student number, read from filename """
        self.name = name; """ Student name, read from filename """
        self.path = path; """ Full path. """
        self.folder = folder; """ Just the folder name (last part of path) """
        self._comment_list = dict(); """ dict of SET of CommentTuple, keyed by question number. """
        self._alternative_comment_list = dict(); """ dict of SET of CommentTuple, keyed by question index.; for comparing different gradings """
        self.script_files = script_files; """ List of filenames (one for each question) of the student's solution scripts to be loaded/executed. Indexed by question index (0-based) """
        self.script_codes = script_codes; """ List of string each containing the contents of the script files. Indexed by question index (0-based) """
        self.script_outputs = script_outputs; """ List of output strings produced by the associated script file when run. Indexed by question index (0-based) """
        self.script_plots = script_plots; """ List of QPixmap objects containing plot images generated by the associated script file, if any (0-based) """

    def __lt__(self, other):
        return self.folder < other.folder

    def print(self):
        """ Print this student's data to console. """
        print("mat_nr: ", self.mat_nr)
        print("name: ", self.name)
        print("path: ", self.path)
        print("folder: ", self.folder)
        print("comments: ", self._comment_list)
        print("alternative comments: ", self._alternative_comment_list);
        print("files: ", self.script_files)
        print("codes: ", self.script_codes)
        print("outputs: ", self.script_outputs)
        print("plots: ", self.script_plots, "\n")


    def add_comment(self, question_nr, comment, comment_type = 'normal'):
        """
        Assign a new comment to this student for a given question. When the comment_type is
        "alternative", it will add the comment to the alternative comment list.
        
        Args:
            question_nr (int): 0-based index of the question the comment applies to.
            comment (CommentTuple): The comment to assign.
        
        Optional arg:
            comment_type (string): possible values 'normal' (default) or 'alternative' 
        """
        if comment_type == 'normal':
            self._comment_list.setdefault(question_nr, set()) # initialize dict value if none found
            self._comment_list[question_nr].add(comment)
        elif comment_type == 'alternative':
            self._alternative_comment_list.setdefault(question_nr, set()) # initialize dict value if none found
            self._alternative_comment_list[question_nr].add(comment) 
    
    def remove_comment(self, question_nr, comment):
        """
        Removes a given comment if it has been assigned for a given question. Does nothing if the comment is not found.
        Args:
            question_nr (int): 0-based index of the question being worked on.
            comment (CommentTuple): The comment to remove
        """
        self._comment_list.setdefault(question_nr, set())  # initialize dict value if none found
        self._comment_list[question_nr].discard(comment)
    
    def clear_comments(self, question_nr, comment_type = 'normal'):
        """
        Remove all comments assigned to this student for a given question. When the comment_type is
        "alternative", it will empty the alternative comment list.
        
        Args:
            question_nr (int): The 0-based index of the question to remove comments for.
            
        Optional arg:
            comment_type (string): possible values 'normal' (default) or 'alternative' 
        """
        if comment_type == 'normal':
            self._comment_list.setdefault(question_nr, set())  # initialize dict value if none found
            self._comment_list[question_nr].clear()
        elif comment_type == 'alternative':
            self._alternative_comment_list.setdefault(question_nr, set())  # initialize dict value if none found
            self._alternative_comment_list[question_nr].clear()
    
    def get_comments(self, question_nr, comment_type = 'normal'):
        """
        Get a list of all comments assigned for a given question. When the comment_type is
        "alternative", it will get the alternative comment list.
        
        Args:
            question_nr: Passing "ALL" will return a flat list of all comments assigned for all questions. Passing
                an integer (used as a 0-based index) will return all comments assigned for that question.
        
        Optional arg:
            comment_type (string): possible values 'normal' (default) or 'alternative' 
        
        Return:
            List of CommentTuples assigned for the given question(s). No order is guaranteed for the returned list.
        """
        if comment_type == 'normal':
            comment_list = self._comment_list
        elif comment_type == 'alternative':
            comment_list = self._alternative_comment_list
        if question_nr == "ALL":
            res = []
            for i in comment_list:
                res.extend(comment_list[i])
            return res
        if question_nr in comment_list:
            return list(comment_list[question_nr])
        return []

class Filter:
    """
    Filter operator class. Applied to each element in a list of students, to determine if that student matches the
    requirements of the selection. Represents a set of constraints which must be fulfilled for a given student to be
    included in the selection. Students must satisfy all constraints individually.
    """
    def __init__(self):
        self.is_inverted = False
        self.with_comment_list = None
        self.in_point_range = None
        self.rnd_perc = None
        self.with_no_comments = False
        self.only_current_question = False
    
    def set_inverted(self, isInverted):
        """
        Sets whether this constraint will be negated (selects all students which do NOT match the criteria).
        Passing anything which does not evaluate to True will set the matches to default (non-inverted) behaviour.
        
        Args:
            isInverted (bool): True to invert the selection, False otherwise.
        """
        self.is_inverted = isInverted
    
    def set_constraint_with_comments(self, comments):
        """
        Define which comments a student must have asigned to be included in the selection.
        
        Args:
            comments: List of CommentTuple. Passing an empty list will result in an empty selection. Passing None
            disables this constraint.
        """
        self.with_comment_list = comments
    
    def set_constraint_in_point_range(self, low, high):
        """
        Specify the range of points (inclusive, inclusive) for students to be included in the selection.
        If the first argument is greater than the second, the selection will be empty. If the first argument is
        equal to the second, the selection will contain student with exactly that number of points.
        
        Args:
            low (int): Lower bound (inclusive) of the point interval
            high (int): Upper bound (inclusive) of the point interval
        """
        self.in_point_range = [low, high]
    
    def set_constraint_with_no_comments(self, isEnabled):
        """
        Boolean constraint to select only students which do not have any comments assigned to them.
        
        Args:
            isEnabled (bool): True to enable this constraint, False to disable it.
        """
        self.with_no_comments = isEnabled
    
    def set_constraint_rnd_percentage(self, perc):
        """
        Constraint to select a percentage of students matching all other constraints at random.
        
        Args:
            perc (int): Percentage of students to include. Should be in [0, 100]. If perc <= 0, the selection will be
            emtpy. If perc >= 100 this constraint has no effect. Passing None disables this constraint
        """
        if not perc or not 0 < perc < 100:
            self.rnd_perc = None
        else:
            self.rnd_perc = int(perc)
    
    def set_only_current_question(self, isOnly):
        """
        Boolean constraint to use only comments applying to the current question when applying a with_comments Filter.
        
        Args:
            isOnly (bool): True to enable this constraint, False to disable it.
        """
        self.only_current_question = isOnly
    
    def matches(self, student, points, current_question):
        """
        Determine whether a given Student object matches this Filter's constraints. The student must match all defined
        constraints individually.
        
        Args:
            student (Student): The Student to evaluate.
            points (int): The number of points assigned to the student
            current_question (int): The current question (used as a 0-based index). Will only be used if the filter has been
            configured to check comments for the current question.

        Returns:
            True if the given student fulfills the constraints, else false.
        """
        matches = True
        if self.with_comment_list is not None:
            if self.only_current_question:
                q = current_question
            else:
                q = "ALL"
            if not [x.comment_id for x in self.with_comment_list if x.comment_id in
                    [y.comment_id for y in student.get_comments(q)]]:
                matches = False
        if self.in_point_range is not None:
            if not self.in_point_range[0] <= points <= self.in_point_range[1]:
                matches = False
        if self.with_no_comments:
            if student.get_comments(current_question):
                matches = False
        if self.rnd_perc is not None:
            if random.randint(0,100) > self.rnd_perc:
                matches = False
        if self.is_inverted:
            matches = not matches
        return matches


class FastGradeEngine(QThread):
    """
    Data processor class. Does all the heavy lifting. Separates functionality from UI class. Called by UI class
    when controls are used.
    
    Lightweight engine, uses minimal internal state and CSV file output.
    """
    countChanged = pyqtSignal(int)  # to signal ui when loading data, for status bar.
    
    def __init__(self):
        super().__init__()
        # vvv Hardcoded variables, cannot be specified by the user, never modified by the code:
        
        # Special files:
        self.input_textfile        = 'microbe_identifiers.txt' # Text/csv/etc input file. Will be protected from modification while loading student data. Student scripts should open and read this file.
        self.output_plot        = 'weights.png' # Image output location for student data. Student scripts should save image/plot output with this name. All other images/plots will be ignored!
        self.config_path         = 'state.pkl' # config file to save/load internal state from.
        self.student_data_pkl_path = 'student_data.pkl' # default filename to save/load student data from.
        self.analysis_module    = 'FastGradeAnalysis'  # base name of the analysis script file to dynamically import for evaluating student code/output.
        try:
            self.analysis = importlib.import_module(self.analysis_module)
        except:
            print(self.analysis_module+'.py raises an error')
        self.script_folder          = os.path.dirname(os.path.realpath(__file__)) # The folder containing this program AND associated files/configs
        self.total_questions     = 7 #Total number of questions on the exam.
        
        # Other hardcoded settings
        self.initial_font_size  = 10 #can be changed by the user afterward
        self.student_data_id_val= "f5208b417e35cc"  # ID string used to check student data pickle file contents
        self.timeout_seconds     = 4 # Maximum allowed execution time per student script, in seconds.
        self.verbose             = False # If true, spam loads of debug messages to the console.
        self.subprocess_shell    = False  # Whether to execute subprocess calls in a shell or not. Don't change this unless you know what you're doing!
        self.initial_points_str    = 'Initial points'  # reserved comment description
        self.initial_points_default = 0.0 #variable for default points for initial points
        self.DCQ_file_header    = 'Comment ID,Question Nr,Points,Comment String'  # Column names to write to DCQ files. Also used to check file structure when loading.
        self.ACQ_file_header    = 'Student ID, Assigned Comment IDs'  # Column names to write to ACQ files. Also used to check file structure when loading.
        self.sel_file_header    = 'Student_ID'  # Column names to write to selection files. Also used to check file structure when loading.
        self.student_file_regex = '^q\d{1,2}_\d{8}_[A-Za-z0-9]+(\.\d{6}-\d{6})?\.py' # Used to filter student files to load. Starts with 'q', followed by a 1- or 2-digit number, 8-digit student id, name and optional 6-6-digit timestamp
        self.alternative_evaluation_checked_str = ' x  ' #String is added before comment when it is selected in alternative evaluation (for comparing different corrections)
        self.alternative_evaluation_unchecked_str = '    ' #!!Must be same length as self.alternative_evaluation_checked_str; for unchecked comments in alternative evaluation
        # ^^^
        
        # Config variables, saved/loaded from config file:
        self.question_index            = 0 # the question number (as 0-based index) being corrected. Filters files loaded. Must be set.
        self.student_data_root        = None # Path to FILE OR FOLDER containing student data to be corrected. Must be set.
        self.user_name                 = None # Username ID for the user currently working on grading. Must be set, used in CSV output.
        self.gradescale_path         = None # Path to python file defining grading function. Optional.
        self.output_path             = self.script_folder # Path to folder where output files should be generated.
        self.output_path_selection    = os.path.join(self.output_path, 'selection') # Path to folder where selection files should be saved/loaded.
        self.output_path_export        = os.path.join(self.output_path, 'overview') # Path to folder where selection files should be saved/loaded.
        self.current_student_index    = 0 # Index of the current student object.
        self.using_gradescale        = False # If True, use gradescale grading. Else use point sum grading.
        self.do_autosave            = True # If True, config/DCQ/ACQ files will automatically be saved when exiting. If False, users must manually save data.
        self.do_autoimport            = True # If True, will attempt to import DCQ/ACQ files for the current user when initializing.
        self.merge_DCQs                = False # If True, loading a DCQ file will merge its contents into the existing comment list for that question instead of overwriting it.
        self.merge_ACQs                = False # If True, loading a DCQ file will merge its contents into the existing student list instead of overwriting it.
        
        # Data variables, store large datasets, frequently modified:
        self.student_list              = [] # List of all loaded student entities.
        self.filtered_student_list      = [] # List of students currently satisfying the specified selection matches. Only these will be displayed.
        self.all_question_comment_list = [] # List of lists of comments. All comment objects for a question are stored in a list, which is stored at that question's index value in this list.
        self.filter                  = Filter() # used to select students. Only matching students will appear in _filteredCommentList.
        self.has_loaded_student_files = False
        self.alternative_evaluation_present = False # When comparing comment assignment files, an alternative evaluation is created
        
        self.load_config() # Will overwrite config variables if a valid config file is found
        self.init_comment_list()
        
    def init_comment_list(self):
        """
        Initialize comment storage structure as list-of-list (one entry per question index) and populate the list for
        each question with a standard initial-points comment.
        """
        self.all_question_comment_list = [[] for _ in range(self.total_questions)]
        for i in range(len(self.all_question_comment_list)):
            self.all_question_comment_list[i].append(
                CommentTuple(comment_id='default', question=i, comment_string=self.initial_points_str, points=self.initial_points_default))#variable for points
    
    def has_required_info(self):
        """
        Returns true if all neccessary data has been supplied so that the engine can be initialized.
        Used to lock UI tabs until required data is entered.
        """
        if self.question_index is None:
            if self.verbose: print("Error: Missing questionIndex")
            return False
        if self.user_name is None:
            if self.verbose: print("Error: Missing user_name")
            return False
        if self.student_data_root is None:
            if self.verbose: print("Error: Missing student_data_root")
            return False
        if self.verbose: print("All required data present")
        return True
    
    def test_system_requirements(self):
        """
        Student scripts are executed using the system's default version of python (which may be different from the
        version used to run this FastGrade script). The function checks whether the system requirements are ok by 
        generating and running a temporary python file ('temp_check_requirments.py') that includes python 3 specific 
        printing and importing libraries that are used during the course. It shows a warning if the system requirements have not
        been met.
        
        Returns:
            true if file can be executed
            
        """
        met_requirements = False
        file_name = 'temp_check_requirements.py'
        fyle = open(file_name, 'w')
        fyle.write('wrongpython = True\n')
        fyle.write("""try: exec('print "system default version of python must be 3 instead of 2"')\nexcept: wrongpython = False\n""")
        fyle.write('if not wrongpython:\n')
        fyle.write("   try: import numpy\n   except: print('numpy library is missing')\n")
        fyle.write("   try: import scipy\n   except: print('scipy library is missing')\n")
        fyle.write("   try: import matplotlib\n   except: print('matplotlib library is missing')\n")
        fyle.write("   try: import time\n   except: print('time library is missing')\n")
        fyle.write("   try: import copy\n   except: print('copy library is missing')\n")
        fyle.write("   try: import random\n   except: print('random library is missing')\n")
        fyle.close()
        code, output, timed_out = self.execute_script(os.path.join(os.getcwd(), file_name))
        os.remove(file_name)
        if len(output.strip()) == 0:
            met_requirements = True
            if self.verbose: print('system requirements ok')
        else:
            output = "Students' code cannot be executed:\n"+output
            QMessageBox.warning(QMessageBox(), 'System requirements', output, QMessageBox.Close)
        return met_requirements
        
    def has_loaded_student_data(self):
        """ Used to check whether student data has successfully been loaded, to subsequently unlock tabs etc. """
        return self.has_loaded_student_files
    
    def process_student_data(self, root_path=None):
        """
        Process student data in a given directory, load and run all student files, generate a list of Student objects
        and store this data structure in a pickle file. Each student object stores all data
        available for a given student (solutions for all questions, not just the current ones).
        COMMENTS ASSIGNED TO STUDENTS ARE RESET AND MUST BE RE-IMPORTED IF REQUIRED!
        The data structure generated is stored in the default location and overwrites that file if it exists.

        Starting in a given directory, iterate through directory contents:
        Ignore files in base folder. Ignore sub-subfolders base folder.
        For each folder F in base folder, create a student object:
            For each file in each F do:
                Filter filenams to only process relevant files.
                Parse filename to get student info (name, studentID, question number)
                Store file contents, file output when executed, and analysis string, in the student object

        Args:
            root_path (string): Folder path from which to start searching. Defaults to current folder.
            
        Returns:
            List of Student objects, each containing all data relevant for that student for all questions. Only
            the newest solution file for a given question is processed.
        """
        self.has_loaded_student_files = False
        if root_path is None:
            root_path = self.student_data_root
        if not os.path.isdir(root_path):
            if self.verbose: print('Error: Specified path is not a directory')
            return
        input_textdata = ''
        try:
            with open(self.input_textfile, 'r') as textfile: # load contents of file intended to be read by student scripts. Contents will be written back after each script is run, to protect against accidental modification
                input_textdata = textfile.read()
        except FileNotFoundError: # File doesn't exist; create an empty file in it's place.
            if self.verbose: print('Input file not found, creating default input file')
            input_textdata = ''
            with open(self.input_textfile, 'w'):
                pass
        student_objects = []
        timed_out_scripts = []
        regex = re.compile(self.student_file_regex)
        for root_path, dirs, files in os.walk(root_path):
            count = 0
            for folder in dirs:  # estimate number of files to be processed for progress bar display.
                for student_path, student_dirs, student_files in os.walk(os.path.join(root_path, folder)):
                    count -= len([x for x in student_files if regex.search(x)])
            for folder in dirs:
                name = None
                mat_nr = None
                script_files = [None] * self.total_questions
                script_codes = [""] * self.total_questions
                script_outputs = [""] * self.total_questions
                script_plots = [None] * self.total_questions
                
                for student_path, student_dirs, student_files in os.walk(os.path.join(root_path, folder)):
                    files = [x for x in student_files if regex.search(x)]
                    if count < 0:  # report number of student files to UI for progress bar. Negative value -> initial, not progress update
                        self.countChanged.emit(count)
                        count = 0
                    groups = defaultdict(list)
                    for file in files:
                        file_question_nr = file.split('_')[0][1:]
                        if int(file_question_nr) > self.total_questions:
                            print('Question number too high in '+student_path+': remove file or increase total_questions in FastGrade.py.')
                            sys.exit()
                        groups[file_question_nr].append(file)
                    for file_question_nr in sorted(groups.keys()):
                        """
                        Select file to load based on filename: OLAT saves files of the forms:
                        <base filename>.YYMMDD-HHMMSS.py or
                        <base filename>.py
                        These are sorted lexicographically, resulting in a list containing all filenames with
                        timestamps (if present) in ascending order by date, FOLLOWED BY the file without a date
                        (if present). Therefore, use these list indices to get specific files:
                        0  : The file with the earliest timestamp if present, else the non-timestamp file.
                        -1 : The non-timestamp file
                        -2 : The file with the latest timestamp if present, else the non-timestamp file.
                        """
                        file = sorted(groups[file_question_nr])[-2 % len(groups[file_question_nr])]
                        index = int(file_question_nr) - 1 # -1 for 0-based indexing
                        if index >= 0: #prevent including q0 files
                            script_files[index] = file
                            if self.verbose: print('executing script:', file)
                            code, output, timed_out = self.execute_script(os.path.join(student_path, file))
                            
                            #add a warning to code output in case the code time out and the output may not be correct
                            if timed_out: output += '\n\n!!!CODE TIMED OUT WHILE GENERATING .PKL-FILE, DOUBLE-CHECK OUTPUT!!!' 
                            
                            # Write back the input text file contents in case the student script modified them accidentally.
                            with open(self.input_textfile, 'w') as textfile:
                                textfile.write(input_textdata)
                            
                            # Load the plot produced by the last script run, if any:
                            try:
                                with open(self.output_plot, "rb") as img:
                                    script_plots[index] = img.read()
                                os.remove(self.output_plot) # remove any plot generated (the same file would otherwise be loaded for subsequent scripts if they do not overwrite it)
                            except FileNotFoundError:
                                if self.verbose: print('No plot file found: %s' % self.output_plot)
                            
                            if timed_out is True:
                                timed_out_scripts.append(file)
                            script_codes[index] = code
                            script_outputs[index] = output
                            if mat_nr is None: # load additional student data from first file encountered only
                                main_filename_part = file.split(".")[0]
                                parts = main_filename_part.split("_")
                                mat_nr = parts[1]
                                name = parts[2]
                            count += 1
                            self.countChanged.emit(count)
                    
                    # set default student ID and name if the folder contained no file to get that data from.
                    if mat_nr is None: mat_nr = 'unknown'
                    if name is None: name = 'unknown'
                    
                    student = Student(mat_nr, name, student_path, folder, script_files, script_codes, script_outputs, script_plots)
                    if self.verbose:
                        print('Loaded student: Mat. Nr: %s, Folder: %s' % (student.mat_nr, student.folder))
                        student.print()
                    student_objects.append(student)
        self.student_list = sorted(student_objects)
        self.filtered_student_list = self.student_list
        self.save_student_data_file(self.student_list)
        self.countChanged.emit(0)  # cosmetic: set progress bar to 100% in case the original file estimate was wrong.
        self.has_loaded_student_files = True
        print('\n\n === FOLLOWING SCRIPTS TIMED OUT DURING IMPORT ===')
        for file in sorted(timed_out_scripts):
            print(file)
        print('===\n\n')
    
    def set_student_data_root_folder(self, folder):
        """
        Sets the folder in which to look for student data
        
        Args:
            folder (string): Folder path to use as the new root folder for student data
        """
        if folder:
            self.student_data_root = folder
            self.has_loaded_student_files = False
            if self.verbose: print("Set base folder: ", folder)
        else:
            if self.verbose: print("Invalid folder")
    
    def set_output_folder(self, folder):
        """
        Sets the folder where generated files will be stored.
        
        Args:
            folder (string): Folder path for file output
        """
        if folder:
            self.output_path = folder
            self.output_path_selection = os.path.join(self.output_path, 'selection')
            self.output_path_export = os.path.join(self.output_path, 'overview')
            if self.verbose: print("Set output folder: ", folder)
        else:
            if self.verbose: print("Invalid folder")
    
    def set_question_nr(self, question_index):
        """
        Sets the current question number being shown/worked on.
        
        Args:
            question_index (int): 0-based question index.
        """
        self.question_index = question_index
        if self.verbose: print("Set question to: ", self.question_index + 1)
    
    def increment_student(self, step='next'):
        """
        Select the previous/next student in the current selection.
        
        Wraps to the start/end if the last/first student was reached. Does not update anything except the current
        student index! Does nothing if the current selection is empty or contains less than two students.
        
        Args:
            step (str): Options are 'next' and 'prev'. Defaults to 'next'
        """
        if not self.filtered_student_list or len(self.filtered_student_list) < 2:
            return
        if step == 'next':
            self.current_student_index += 1
            self.current_student_index %= len(self.filtered_student_list)
        elif step == 'prev':
            if self.current_student_index == 0:
                self.current_student_index = len(self.filtered_student_list) - 1
            else:
                self.current_student_index -= 1
    
    def set_current_student_by_folder(self, folder_name):
        """
        Set the current student index based on a given student folder name.
        
        Does nothing if the given folder is not present in the current student selection.
        
        Args:
            folder_name (string): The folder name of the student to set as current.
        
        Returns:
            None
        """
        folders = [x.folder for x in self.filtered_student_list]
        if folder_name in folders:
            self.current_student_index = folders.index(folder_name)
            if self.verbose: print("set student folder to: %s" % self.current_student_index)
        else:
            if self.verbose: print("Cannot find specified student folder")
    
    # def analyze_script(self, script_path, question_index, script_args):
    #     """
    #     Run a given script and analyze its output.
    #
    #     Args:
    #         question_index (int): Current question index. Used by the analysis function to evaluate the script for
    #         the correct question.
    #         script_path (string): Path to the student solution file.
    #         script_args (string) Optional argument string to pass to the script.
    #
    #     Returns:
    #         code (string): The contents of the script file
    #         output (string): The console output produced by the script.
    #         expected (string): The expected output for a solution to the current question.
    #         analysis (string): Output of the analysis function for output and expected strings.
    #     """
    #     code, output = self.execute_script(script_path, script_args)
    #     expected, analysis = self.analysis.analyze(question_index, output)
    #     return code, output, expected, analysis
    
    def execute_script(self, script_path, script_args=''):
        """
        Load and run the given script, return its file contents and output.
        Newer version of this method, only uses subprocess (hopefully more futureproof than easyprocess)
        Scripts are run in the directory they are loaded from and any output files will be generated there.
        
        Args:
            script_path (string): Full path to the student solution file to run.
            script_args (string) Optional argument string to pass to the script.
        
        Returns:
            code (string): The contents of the script file
            output (string): The console output produced by the student script, including exception messages
            timed_out (bool): True if the script timed out and execution was interrupted. Else False.
        """
        try:
            f = open(script_path, 'r')
            code = f.read()
        except EOFError:
            if self.verbose: print("Error: Could not read file")
            return
        except FileNotFoundError:
            if self.verbose: print("Error: Solution file not found")
            return
        output = ''
        timed_out = False
        if script_path:
            if self.subprocess_shell:
                cmd = 'python %s %s' % (script_path, script_args)
            else:
                cmd = ['python', '-u', script_path, script_args]
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            try:
                out, err = proc.communicate(timeout=self.timeout_seconds)
            except subprocess.TimeoutExpired:
                proc.kill()
                out, err = proc.communicate()
                timed_out = True
            output = '\n'.join([out.decode('utf8'), err.decode('utf8')])
        else:
            if self.verbose: print("No script to execute")
        return code, output, timed_out
    
    def get_current(self, data='STUDENT'):
        """
        Return data concerning the current student and script.
        
        Args:
            data (string): specifies the type of data to return. Possible values are: 'STUDENT', 'FILENAME', 'PLOT',
            'SCRIPTCODE', 'SCRIPTOUTPUT', 'SCRIPTANALYSIS'.

        Returns:
            Depending on the argument specified:
            STUDENT: The current student object
            FILENAME: The name of the student solution file for the current question
            PLOT: The plot image generated by the student solution file for the current question
            SCRIPTCODE: Script file contents (as string) of the current student's solution to the current question
            SCRIPTOUTPUT: Script output (as string) of the current student's solution to the current question
            SCRIPTANALYSIS: a tuple containing the expected output string, and the analysis result string for the
            current student script for the current question. Results are determined by the external analysis script.
            All calls return None if there is no current student defined, or if the specified data object is not available.
        """
        student = None
        if self.filtered_student_list:
            student = self.filtered_student_list[self.current_student_index]
        if not student and self.verbose: print("Error: No student specified. No student data available.")
        if data == 'STUDENT':
            return student
        elif data == 'FILENAME':
            if student:
                return student.script_files[self.question_index]
        elif data == 'PLOT':
            if student:
                return student.script_plots[self.question_index]
        elif data == 'SCRIPTCODE':
            if student:
                return student.script_codes[self.question_index]
        elif data == 'SCRIPTOUTPUT':
            if student:
                return student.script_outputs[self.question_index]
        elif data == 'SCRIPTANALYSIS':
            try:
                return self.analysis.analyze(self.question_index, self.get_current('SCRIPTOUTPUT'))
            except:
                return 'no expected output can be generated, since '+self.analysis_module+'.py raises an error', 'no analysis of results can be generated, since '+self.analysis_module+'.py raises an error'
        else:
            if self.verbose: print('Error: Unrecognized data key')
        return None
    
    def is_using_gradescale(self):
        """
        Determines whether gradescale (external) grading is currently being used.
        
        Returns:
            False unless a gradescale file has been specified AND the gradescale is enabled
        """
        if self.gradescale_path is None:
            return False
        return self.using_gradescale
    
    def get_question_index(self):
        """ Returns the 0-based index of the current question (working question) """
        return self.question_index
    
    def get_full_student_list(self):
        """
        Returns a list of all students. This is not the working student list (filtered_student_list is)!
        Not necessarily sorted!
        """
        return self.student_list
    
    def get_filtered_student_list(self):
        """
        Returns a list of all students matching the current selection constraints. Is also the working list.
        Not necessarily sorted!
        """
        return self.filtered_student_list
    
    def get_comment_list(self, question=None):
        """
        Get a list of comments for the given question and sort it.
        
        Args:
            question: May be string "ALL" or integer. The 0-based index of the question to return comments for.
            Defaults to the current question.
        
        Returns:
            If question == "ALL", returns a FLATTENED list of list of CommentTuple for all questions
            If question is an integer, returns the list of CommentTuples for the given question index
        """
        #for sorting; sort to question, within question initial points first
        def func(x):
            x3 = x[3]
            if x3 == 'Initial points':
                x3 = '0'
            return str(x[1])+x3
        
        if question is None:
            return sorted(self.all_question_comment_list[self.question_index], key = func)
        if question == "ALL":
            return sorted([x for sublist in self.all_question_comment_list for x in sublist], key = func) # flatten list
        else:
            return sorted(self.all_question_comment_list[question], key = func)
    
    def get_comment_list_in_use(self, question=None):
        """
        Get the list of comments which have been assigned to at least one student for the given question.

        Args:
            question: May be "ALL" or an integer. The 0-based index of the question to return unused comments for.
            Defaults to current question.
        
        Returns:
            If question == "ALL", returns a list of CommentTuple containing all comments assigned for all questions.
            If question is an integer, returns the list of CommentTuples for the given question
        """
        if question is None:
            question=self.question_index
        comments = set()
        for s in self.student_list:
            comments.update(s.get_comments(question))
        return list(comments)
    
    def add_rename_comment(self, comment_str, str_to_replace=None, points=0):
        """
        Create a new comment (identified by its text string) if it is valid and not already present, or rename an
        existing comment.
        
        New comments will be added to the comment list for the current question.
        
        Comments include a unique ID string to prevents collisions when merging comment files produced by separate users.
        
        Args:
            comment_str (string):
                The description/name of the new comment to add. Must contain at least one non-whitespace character,
                may not contain characters ',' or ':' and must be distinct (regardless of case) from all existing
                comments for the current question.
            str_to_replace (string):
                The comment text of the comment to be renamed. If present, renaming mode will be used and no new comment
                will be created. If no comment is found with this text, this call does nothing.
            points (float):
                The points to assign for the new comment. Defaults to 0. Ignored in renaming mode.
        """
        if comment_str == '' or comment_str.isspace():
            if self.verbose: print("Please enter comment description")
            return
        if comment_str.find(',') != -1 or comment_str.find(':') != -1:
            if self.verbose: print("Comment description may not contain ',' or ':' characters")
            return
        # compare lowercase strings only to avoid case duplicates:
        if not str_to_replace and comment_str.lower() in [x.comment_string.lower()
                                                          for x in self.all_question_comment_list[self.question_index]]:
            if self.verbose: print("Comment already exists")
            return
        hash_id_length = 8 # characters in id strings. 8 chars has ~4.3E-9 collision chance
        if str_to_replace: # renaming mode
            comment = next(x for x in self.all_question_comment_list[self.question_index] if x.comment_string == str_to_replace)
            if comment:
                renamed_comment = comment._replace(comment_string=comment_str)
                idx = self.all_question_comment_list[self.question_index].index(comment)
                self.all_question_comment_list[self.question_index][idx] = renamed_comment
                # replace comment tuple in all students it was assigned to, since _replace returns a new CommentTuple
                # instead of modifying an existing one:
                assigned_students = (x for x in self.student_list if comment in x.get_comments(self.question_index))
                for x in assigned_students:
                    x.remove_comment(self.question_index, comment)
                    x.add_comment(self.question_index, renamed_comment)
                if self.verbose: print("Renamed Comment '%s' to '%s'" % (comment, renamed_comment))
                if self.alternative_evaluation_present:
                    assigned_students = (x for x in self.student_list if comment in x.get_comments(self.question_index))
                    for x in assigned_students:
                        x.remove_comment(self.question_index, comment)
                        x.add_comment(self.question_index, renamed_comment)
                    
        else: # create new comment
            id_string = uuid.uuid4().hex[:hash_id_length]
            comment = CommentTuple(comment_id=id_string, question=self.question_index, points=points, comment_string=comment_str)
            self.all_question_comment_list[self.question_index].append(comment)
            if self.verbose: print("Added Comment '%s'" % str(comment))
    
    def delete_comment(self, comment_str):
        """
        Remove all comments matching a given comment description string from the list of comments for the current
        question. There should be at most one such comment in the list.
        
        Truncates the given string to the first occurrence of ":\t" before searching.
        
        Args:
                comment_str (string): Description string for the comment to be deleted.
        """
        comment_text = comment_str.split(":\t", 1)[0]
        if self.verbose: print('Comment text: %s' % comment_text)
        if comment_text != self.initial_points_str:
            self.all_question_comment_list[self.question_index] = [
                x for x in self.all_question_comment_list[self.question_index] if x.comment_string != comment_text]
            if self.verbose: print("Deleted Comment '%s'" % comment_str)
    
    def set_comment_points(self, comment_str, comment_points):
        """
        Set the point value of a given comment (identified by its text string). Does nothing if no comment with the
        given string exists for the current question. Will not modify the 'initial points' comment
        
        Truncates the given string to the first occurrence of ":\t" before searching.
        
        Args:
            comment_str (string): Description string for the comment to be modified.
            comment_points (float): The new point value to set for the comment.
        """
        comment_text = comment_str.split(":\t", 1)[0]
        if comment_text != self.initial_points_str:
            comment_index = next(index for index, x in enumerate(self.all_question_comment_list[self.question_index]) if
                             x.comment_string == comment_text)
            comment = self.all_question_comment_list[self.question_index][comment_index]
            revalued_comment = comment._replace(points=comment_points)
            self.all_question_comment_list[self.question_index][comment_index] = revalued_comment
            # replace comment tuple in all students it was assigned to, since _replace returns a new CommentTuple
            # instead of modifying an existing one:
            assigned_students = (x for x in self.student_list if comment in x.get_comments(self.question_index))
            for x in assigned_students:
                x.remove_comment(self.question_index, comment)
                x.add_comment(self.question_index, revalued_comment)
            if self.verbose: print("Updated comment points for comment '%s' to '%s'" % (comment_str, comment_points))
    
    def set_initial_points(self, initial_points):
        """ Set the initial points assigned for the current question. """
        comment_index = next(i for i, x in enumerate(self.all_question_comment_list[self.question_index]) if
                         x.comment_string == self.initial_points_str)
        comment = self.all_question_comment_list[self.question_index][comment_index]
        self.all_question_comment_list[self.question_index][comment_index] = comment._replace(points=initial_points)
        if self.verbose: print("Updated initial points for question %s to %s" % (self.question_index, initial_points))
    
    def get_student_question_score(self, question_index, student):
        """
        Recalculates and returns the total amount of points assigned to the given student for the given question.
        Uses point sum / gradescale grading as appropriate.
        
        Args:
            question_index (int): The 0-based index of the question to use. Defaults to the current question.
            student (StudentTuple): The student to evaluate. Defaults to the current student.
        
        Returns:
            Point score (float) currently assigned to the given student for the solution to the given question
        """
        if question_index is None:
            question_index = self.question_index
        if student is None:
            student = self.get_current()
        applied_comments = student.get_comments(question_index)
        if self.is_using_gradescale():
            file = self.gradescale_path
            gradescale = importlib.machinery.SourceFileLoader(file, os.path.basename(file)).load_module()
            points = gradescale.run(question_index, applied_comments)
        else:
            initial_points = next(x for i, x in enumerate(self.all_question_comment_list[question_index]) if
                               x.comment_string == self.initial_points_str).points
            points = initial_points + sum(x.points for x in applied_comments)
            if points < 0: points = 0 # not 0.0, so that it can be checked whether this occurs
        return points
    
    def get_student_total_score(self, student=None):
        """
        Recalculates and returns the total amount of points assigned to the given student for all questions.
        Uses point sum / gradescale grading as appropriate.
        
        Args:
            student (StudentTuple): The student to evaluate. Defaults to the current student.
        
        Returns:
            Point score (float) currently assigned to the given student for the solutions to all questions
        """
        if student is None:
            student = self.get_current()
        return sum(self.get_student_question_score(i, student) for i in range(self.total_questions))
    
    def load_student_data_file(self, file):
        """
        Attempts to load student data from an existing file (assumed to be in pkl format) as produced by
        process_student_data(). Replaces any existing student list data and resets current selection. If the file is not
        found or reading fails, this call does nothing. Does not initialize engine, etc.
        
        Args:
            file: Path to the file to open.
        """
        try:
            with open(file, 'rb') as f:
                id_val, data = pickle.load(f)
                if id_val == self.student_data_id_val:
                    self.student_list = data
                    self.filtered_student_list = self.student_list
                    self.has_loaded_student_files = True
                    self.student_data_root = file
        except EOFError:
            if self.verbose: print("Error: Could not read file ", file)
        except (IndexError, ValueError):
            if self.verbose: print("Error: Not a valid config file.")
        except FileNotFoundError:
            if self.verbose: print("Error: No config file found.")
    
    def save_student_data_file(self, data):
        """
        Saves a given list of Student objects to the default location as a pickle file.
        An id string is saved as well to allow data type checks when loading.
        
        Args:
            data: List of student objects to save
        """
        with open(self.student_data_pkl_path, 'wb') as f:
            pickle.dump([self.student_data_id_val, data], f)
        if self.verbose: print("Saved student data file: %s" % self.student_data_pkl_path)
    
    def load_DCQ_file(self, file):
        """
        Load a file from a given path and return a
        
        Args:
            file (string): Path to the file to load
        
        Return:
            List of CommentTuple constructed from the lines in the file, as well as the question number (as a 0-based
            index) that the file applies to. Returns None if the first line in the given file does not match the
            expected header for an ACQ file.
        """
        try:
            q_nr = int(file.split('_')[-2].split('.')[0]) - 1 # assume 1-based filenames as produced by save_DCQ_file()
        except ValueError as e:
            if self.verbose: print("Error: %s" % repr(e))
            return None, None
        comments = []
        with open(file, "r") as f:
            content = [line.rstrip('\n') for line in f]
            if content[0] != self.DCQ_file_header:
                if self.verbose: print("Error: Unrecognized file struture")
                return None, None
            for line in content[1:]: # ignore first line
                line_csv = csv.reader([line], skipinitialspace=True)
                for row in line_csv:
                    if len(row)>0: comment = CommentTuple(comment_id=row[0], question=int(row[1])-1,
                                             points=float(row[2]), comment_string=row[3])
                    comments.append(comment)
        return comments, q_nr
    
    def load_ACQ_file(self, file):
        """
        Load a file from a given path and return a list of tuples (studentID, [commentID]) from the lines in the file,
        as well as the question number (as a 0-based index) that the file applies to.
        
        Args:
            file (string): Path to the file to load
        
        Returns:
            List of tuples, question number to which the assignments apply. Tuples hav the form: (studentFolder, [comment_id, ...])
            None if the first line in the given file does not match the expected header for an ACQ file.
        """
        try:
            q_nr = int(file.split('_')[-2].split('.')[0])-1 # assume 1-based filenames as produced by save_ACQ_file()
        except ValueError as e:
            if self.verbose: print("Error: %s" % repr(e))
            return None, None
        tuples = []
        with open(file, "r") as f:
            content = [line.rstrip('\n') for line in f]
            if content[0] != self.ACQ_file_header:
                if self.verbose: print("Error: Unrecognized file struture")
                return None, None
            for line in content[1:]:
                line = line.replace('[', '"')
                line = line.replace(']', '"')
                line_csv = csv.reader([line], skipinitialspace=True)
                for row in line_csv:
                    if len(row)>0: tuples.append((row[0], row[1].split(',')))
        return tuples, q_nr
    
    def load_sel_file(self, file):
        """
        Load a file from a given path and return a list of student ID strings from the lines in the file.
        Returns an empty list if the first line in the given file does not match the expected header for a selection
        file.
        
        Using csv reader isn't really necessary (only one value per line) but makes it easier if selection file
        structure should change later.
        """
        student_ids = []
        with open(file, "r") as f:
            content = [line.rstrip('\n') for line in f]
            if content[0] != self.sel_file_header:
                if self.verbose: print("Error: Unrecognized file structure")
                return []
            for line in content[1:]:
                line_csv = csv.reader([line], skipinitialspace=True)
                for row in line_csv:
                    if len(row)>0: student_ids.append(row[0])
        return student_ids
    
    def save_DCQ_file(self, question='CURRENT'):
        """
        Generates CSV files from the currently defined comments. Files are named automatically using the current
        username and the question number they store comments for: definedCommentsQuestion_<questionNr>_<user_name>.csv
        The first line lists column names: "Comment ID, question Nr, Points, Comment String"
        Subsequent lines contain data from one comment per line.
        Each file stores all comments for a single question. Files are stored into the configured output folder.
        QUESTION NUMBERS IN FILES AND FILENAMES ARE 1-BASED!
        Args:
            question: The the question index (0-based) to store comments for. If specified, a file will only be
                generated for that question. Defaults to the current question (same as by passing 'CURRENT'). Files may
                be generated for all questions (even if no comments are defined for it) by passing "ALL" or for all
                questions for which comments are defined by passing 'ALL_WITH_CONTENTS'.
        """
        if question == 'CURRENT':
            question_list = [self.question_index]
        elif question == "ALL":
            question_list = range(self.total_questions)
        elif question == 'ALL_WITH_CONTENTS':
            question_list = []
            for q in range(self.total_questions):
                if len(self.all_question_comment_list[q]) > 1:
                    question_list.append(q)
                elif self.all_question_comment_list[q][0].points != self.initial_points_default:
                    question_list.append(q)
        else:
            question_list = [int(question)]
        try:
            for q in question_list:
                filename = "definedCommentsQuestion_%s_%s.csv" % (str(q + 1), self.user_name)
                path = os.path.join(self.output_path, filename)
                with open(path, 'w') as f:
                    f.write(self.DCQ_file_header + '\n')
                    for comment in self.all_question_comment_list[q]:
                        f.write('%s,%s,%s,%s\n' % (str(comment.comment_id), str(comment.question+1),
                                                   str(comment.points), comment.comment_string))
        except:
            m = 'Saving files was not completed, check that '+filename+' is not open in another program'
            choice = QMessageBox.warning(QMessageBox(), 'File writing error', m, QMessageBox.Retry | QMessageBox.Close, QMessageBox.Retry)
            if choice == QMessageBox.Retry:
                self.save_DCQ_file(question)
                
    def save_ACQ_file(self, question='CURRENT'):
        """
        Generates CSV files from the comments currently assigned to students. Files are named automatically using the
        current username and the question number they store data for: assignedCommentsQuestion_<questionNr>_<username>.csv
        The first line lists column names: "Student ID, Assigned Comment IDs"
        Subsequent lines contain data for one student per line.
        The second column contains a variable-length list of comment ID values, enclosed in brackets '[]', sorted by
        comment description string.
        Each file stores all assigned student comments for a single question. Files are stored into the configured
        output folder.
        QUESTION NUMBERS IN FILES AND FILENAMES ARE 1-BASED!
        Args:
            question: The the question index (0-based) to store data for. If specified, a file will only be
            generated for that question. By default, a separate file will be generated for the current question, even
            if no comments have been assigned to students for that question. Files may be generated for all questions
            (even if no comments are defined for it) by passing "ALL" or for all questions for which comments are
            defined by passing 'ALL_WITH_CONTENTS'.
        """
        if question == 'CURRENT':
            question_list = [self.question_index]
        elif question == 'ALL':
            question_list = range(self.total_questions)
        elif question == 'ALL_WITH_CONTENTS':
            question_list = []
            for q in range(self.total_questions):
                for student in self.student_list:
                    if student.get_comments(q):
                        question_list.append(q)
                        break   
        else:
            question_list = [int(question)]
        try:
            for q in question_list:
                filename = "assignedCommentsQuestion_%s_%s.csv" % (str(q + 1), self.user_name)
                path = os.path.join(self.output_path, filename)
                with open(path, 'w') as f:
                    f.write(self.ACQ_file_header + '\n')
                    if self.verbose: print(self.student_list)
                    for student in self.student_list:
                        if self.verbose: student.print()
                        comments = student.get_comments(q)
                        if comments:
                            sorted_comments = [c.comment_id for c in sorted(comments, key=attrgetter('comment_string'))]
                            comment_string = '[%s]' % ','.join(map(str, sorted_comments)) # remove quotes around list elements
                        else: # This student has no comments assigned for the given question
                            comment_string = '[]'
                        linestring = '%s,%s\n' % (student.folder, comment_string)
                        if self.verbose: print('linestring:', linestring)
                        f.write(linestring)
        except:
            m = 'Saving files was not completed, check that '+filename+' is not open in another program'
            choice = QMessageBox.warning(QMessageBox(), 'File writing error', m, QMessageBox.Retry | QMessageBox.Close, QMessageBox.Retry)
            if choice == QMessageBox.Retry:
                self.save_ACQ_file(question)
    
    def save_sel_file(self, selection_name='default'):
        """
        Saves the current selection list in a CSV-style file. The output file will be named
        "selection_<selection_name>.csv" and contain a single column of student folder names which comprise the current
        selection.
        
        Args:
            selection_name (string): Name to save the selection as, used in the output filename.
        """
        if not os.path.exists(self.output_path_selection):
            os.makedirs(self.output_path_selection)
        filename = 'selection_%s.csv' % selection_name
        try:
            with open(os.path.join(self.output_path_selection, filename), 'w') as f:
                f.write('Student_ID\n')
                for student in self.filtered_student_list:
                    f.write('%s\n' % student.folder)
        except:
            m = 'Saving was not completed, check that '+filename+' is not open in another program'
            choice = QMessageBox.warning(QMessageBox(), 'File writing error', m, QMessageBox.Retry | QMessageBox.Close, QMessageBox.Retry)
            if choice == QMessageBox.Retry:
                self.save_sel_file(selection_name)
    
    def save_config(self):
        """
        Save the current configuration (username, file/folder paths, current student, current question etc.)
        so that it can be reloaded at next startup.
        DOES NOT STORE BULK DATA! This only saves a small config file - student/comment/selection data ist not included.
        Filename is hardcoded, not selectable.
        """
        with open(self.config_path, 'wb') as f:
            pickle.dump([self.question_index,
                         self.student_data_root,
                         self.user_name,
                         self.gradescale_path,
                         self.output_path,
                         self.output_path_export,
                         self.output_path_selection,
                         self.current_student_index,
                         self.using_gradescale,
                         self.do_autosave,
                         self.do_autoimport,
                         self.merge_DCQs,
                         self.merge_ACQs
                        ], f)
        if self.verbose: print("Saved config file: %s" % self.config_path)
    
    def load_config(self, file=None):
        """
        Load a config file  and overwrite variables with its contents. If the file is not found or reading fails, this
        call does nothing.
        Does not re-initialize engine, load student data or update student lists!
        
        Args:
            file (string): Path to the file to load. Defaults to standard state file path.
        """
        try:
            if file is None:
                file = self.config_path
            with open(file, 'rb') as f:
                self.question_index, \
                self.student_data_root, \
                self.user_name, \
                self.gradescale_path, \
                self.output_path, \
                self.output_path_export, \
                self.output_path_selection, \
                self.current_student_index, \
                self.using_gradescale, \
                self.do_autosave, \
                self.do_autoimport, \
                self.merge_DCQs, \
                self.merge_ACQs = pickle.load(f)
            self.has_loaded_student_files = False
        except EOFError:
            if self.verbose: print("Error: Could not read config file ", file)
        except (IndexError, ValueError):
            if self.verbose: print("Error: Not a valid config file.")
        except FileNotFoundError:
            if self.verbose: print("Error: No config file found.")
    
    def import_DCQ(self, file, merge=False):
        """
        Replace or update the current comment list for one question with data loaded from a file. The question to be
        modified is determined from the filename - comments for other questions are ignored!
        Does not re-initialize engine or update data other than the comment list!
        
        Args:
            file (string): Path to the file to load. Assumed to be in the same format as produced by save_DCQ_file()
            merge (bool): If True, merge the comments loaded from file into the existing comment list. If False,
                replace the existing comment list with the comments loaded from file. Duplicates are removed.
        """
        comments, q_nr = self.load_DCQ_file(file)
        if comments:
            comments = [x for x in comments if x.question == q_nr] # only process comments for the appropriate question.
            self.all_question_comment_list[q_nr] = self.all_question_comment_list[q_nr]
            if merge:
                self.all_question_comment_list[q_nr] += list(set(comments) - set(self.all_question_comment_list[q_nr]))
                if [x.comment_string for x in self.all_question_comment_list[q_nr]].count(self.initial_points_str) > 1:
                    # Remove first occurrence of an initial points comment if there is more than one.
                    # This happens if a DCQ file is merged with an empty comment list (containing only the default
                    # initial points comment).
                    for i, e in enumerate(self.all_question_comment_list[q_nr]):
                        if e.comment_string == self.initial_points_str:
                            self.all_question_comment_list[q_nr].pop(i)
                            break
            else:
                self.all_question_comment_list[q_nr] = comments
    
    def import_ACQ(self, file, merge=False, comment_type = 'normal'):
        """
        Replace or update the comments currently assigned to students with ones read from a file. Ignores the current
        selection and modifies all Students with IDs that appear in the file. Modifies assigned comment lists only for
        the question specified in the filename! Comment assignments read from the file are ignored unless a comment
        with the same ID is found in self.all_question_comment_list[q_nr]!
        When the comment_type is "alternative", comments will be added to the alternative comment list.
        
        Args:
            file (string): Path to the file to load. Assumed to be in the same format as produced by save_ACQ_file().
                The relevant question number is read from the filename (assumed to use base-1 indexing).
            merge (bool): If True, merge the comment assignments loaded from file into the existing student comment
                lists. If False, replace existing assigned comment lists with those loaded from file. Duplicates are
                removed.
        
        Optional arg:
            comment_type (string): possible values 'normal' (default) or 'alternative' 
        """
        tuples, q_nr = self.load_ACQ_file(file)
        if tuples:
            for tup in tuples:
                student = next((x for x in self.student_list if x.folder == tup[0]), None)
                if student:
                    if not merge: # since Student stores comments in sets, duplicates are automatically removed.
                        student.clear_comments(q_nr, comment_type = comment_type)
                    for comment in [c for c in self.all_question_comment_list[q_nr] if c.comment_id in tup[1]]:
                        student.add_comment(q_nr, comment, comment_type = comment_type)
    
    def import_sel(self, selection_name):
        """
        Replace the current list of selected students with one loaded from a selection file. If the file contains
        student IDs which are not recognized (i.e. not present in the list of all students), they will be ignored.
        Args:
            selection_name (string): The name of the selection (not the filename!) to load.
        """
        if not selection_name:
            if self.verbose: print("Error: No selection specified.")
            return
        filename = "selection_%s.csv" % selection_name
        student_ids = self.load_sel_file(os.path.join(self.output_path_selection, filename))
        self.filtered_student_list = [x for x in self.student_list if x.folder in student_ids]
    
    def initialize_system(self):
        """
        Checks whether all necessary variables have been set. If so, first checks whether there are already student
        data present. If so, it ask the user whether current data must be saved. After that, it attempts to load
        student data and initialize the engine. If student codes must be run, it first checks system compatibility
        (python 3 + presence of dictionaries). Should be called whenever program settings (Init tab) are changed.
        Changes nothing if required variables have not been set.
        """
        
        if self.has_required_info():
            previous_sel = []
            for st in self.filtered_student_list:
                previous_sel.append(st.folder)
            if len(self.student_list) > 0:
                m = "Initializing resets data. Save defined and assigned comments first using current user name ("+self.user_name+")?"
                choice = QMessageBox.question(QMessageBox(), 'FastGrade', m,
                                               QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.Yes)
                if choice == QMessageBox.Yes:
                    self.save_DCQ_file('ALL_WITH_CONTENTS')
                    self.save_ACQ_file('ALL_WITH_CONTENTS')
                    #self.save_config() #not so intuitive: what username should it use?
                elif choice == QMessageBox.Cancel:
                    #event.ignore()
                    return
            self.current_student_index = 0
            if os.path.isdir(self.student_data_root):
                if self.test_system_requirements():
                    self.process_student_data()
                else:
                    return
            else:
                self.load_student_data_file(self.student_data_root)
            #self.apply_filter() this yielded an empty selection if a filter was set, therefore option below instead
            #thus the selection does not change upon initialization
            if len(previous_sel)>0: 
                try: #may give an error if student lists are different upon initialization
                    self.filtered_student_list = [x for x in self.filtered_student_list if x.folder in previous_sel] 
                except:
                    if self.verbose: print("Previous selection could not be kept")
            if self.verbose: print("Engine initialized, all data loaded.")
            self.init_comment_list()
        else:
            if self.verbose: print("Could not initialize engine with current data.")
        # If enabled, attempt to auto-import DCQ/ACQ files for the current question:
        if self.do_autoimport:
            for i in range(self.total_questions):
                dcq = "definedCommentsQuestion_%s_%s.csv" % (i + 1, self.user_name)
                acq = "assignedCommentsQuestion_%s_%s.csv" % (i + 1, self.user_name)
                dpath = os.path.join(self.output_path, dcq)
                apath = os.path.join(self.output_path, acq)
                if os.path.isfile(dpath):
                    self.import_DCQ(dpath)
                if os.path.isfile(apath):
                    self.import_ACQ(apath)
    
    def apply_filter(self):
        """
        Update the visible list of students to match the current selection.
        The starting point is the CURRENT visible list!
        NOTE: FILTERING BY ASSIGNED COMMENTS CONSIDERS ONLY COMMENTS ASSIGNED FOR THE CURRENT QUESTION!
        """
        if not self.filter: # matches list empty or None
            self.filtered_student_list = self.student_list
        else:
            if self.filter.only_current_question:
                self.filtered_student_list = [x for x in self.filtered_student_list if self.filter.matches(
                    x, self.calculate_student_points(self.question_index, x), self.question_index)]
            else:
                self.filtered_student_list = [x for x in self.filtered_student_list if self.filter.matches(
                    x, self.calculate_student_points_all_questions(x), self.question_index)]
        self.current_student_index = 0 # avoid array overrun errors
    
    def modify_selection(self, mode, sel_names):
        """
        Modify the current list of selected students based on a given list of selection NAMES (not filenames).
        Each selection in the list is used to modify the given slection individually.
        Note: Comment Difference operations are handled by do_comment_diff_selection() instead

        Args:
            mode (str): Signifies which type of modification to perform. Options are:
                'AND' (set intersection between current selection and all students in chosen selections),
                'OR' (set union between current selection and all students in chosen selections),
                'EXCEPT' (exclude all students in chosen selections from the current selection),
                "ALL" (reset current selection to include all students)
            sel_names: List of selection names be used
        """
        if mode == "ALL":
            self.filtered_student_list = self.student_list
            return
        if not sel_names:
            if self.verbose: print("Error: No rules selected, can't modify current selection.")
            return
        student_id_selections = []
        for name in sel_names:
            filename = os.path.join(self.output_path_selection, "selection_%s.csv" % name)
            student_id_selections.append(self.load_sel_file(filename))
        if mode == 'AND':
            for sel in student_id_selections:
                self.filtered_student_list = [x for x in self.filtered_student_list if x.folder in sel]
        elif mode == 'OR':
            for sel in student_id_selections:
                self.filtered_student_list = list(
                    set(self.filtered_student_list) | set([x for x in self.student_list if x.folder in sel]))
        elif mode == 'EXCEPT':
            for sel in student_id_selections:
                self.filtered_student_list = [x for x in self.filtered_student_list if x.folder not in sel]
        self.filtered_student_list.sort()
        self.current_student_index = 0 # reset index to prevent array overun errors by ui
    
    def do_comment_diff_selection(self, file):
        """
        Modifies the current selection to show only those students which were present in the selection, AND do not have
        comment assignments which are not identical to the assignments loaded from the file. If the file contains
        assignments for students which are not present in the current selection, the associated file data is ignored.
        If an existing student is NOT present in the file, it will be included in the selection
        Comment assignments in the file with IDs which do not match any of the currently loaded/imported comments are
        ignored. This call does nothing if the file cannot be loaded correctly, or if the file is for a question
        other than the current one.
        NOTE: Comments are only compared for the question number loaded from the file, even if the file contains
        other comments.
        
        Args:
            file: Path to the file to load and compare with. Assumed to be of the form produced by save_ACQ_file().
        """
        other_tuples, q_nr = self.load_ACQ_file(file)
        if q_nr != self.question_index:
            if self.verbose: print("Error: Cannot compare with files for a different question")
            return
        if other_tuples:
            selected = []
            other_folders = [x[0] for x in other_tuples]
            for student in self.filtered_student_list:
                if student.folder in other_folders:
                    other_comment_ids = set(next(x[1] for x in other_tuples if x[0] == student.folder))
                    other_comment_ids.discard('') # drop empty string if present so that empty assignment sets are compared properly
                    own_comment_ids = set([x.comment_id for x in student.get_comments(self.question_index)])
                    if own_comment_ids ^ other_comment_ids: # comments don't match (symmtric difference)
                        selected.append(student)
                        if self.verbose: print('appended: ', student.folder)
                else:
                    selected.append(student) # include students which are not present in the file
            self.filtered_student_list = selected
            self.current_student_index = 0  # reset student index to prevent array overrun errors by ui
    
    def clear_alternative_comments(self):
        """Deletes all alternative assigned comments for each student and each question."""
        
        for student in self.student_list:
            for q_nr in range(self.total_questions):
                student.clear_comments(q_nr, comment_type = 'alternative')
    
    def calculate_student_points_all_questions(self, student=None):
        """
        Calculate total student points for all questions.
        
        Args:
            student (Student): The student to calculate score for. Defaults to current student.
        
        Returns:
            The point score (as float) calculated.
        
        """
        return sum([self.calculate_student_points(q, student) for q in range(0, self.total_questions)])
    
    def calculate_student_points(self, question_index=None, student=None):
        """
        Calculate and return the total points for the currently loaded student answer, using either point sum grading or
        by loading a python script which specifies an arbitrary grading function.
        
        Args:
            question_index (int): The 0-based index of the question to calculate score for. Defaults to current question
            student (Student): The student to calculate score for. Defaults to current student.
        
        Returns:
            The point score (as float) calculated.
        """
        if question_index is None:
            question_index = self.question_index
        if student is None:
            student = self.get_current()
        if not student:
            if self.verbose: print("Error: No student specified. Cannot calculate points.")
            return None
        comments = student.get_comments(question_index)
        if self.is_using_gradescale():
            if self.gradescale_path:
                file = self.gradescale_path
                gradescale = importlib.machinery.SourceFileLoader(file, os.path.basename(file)).load_module()
                points = gradescale.run(question_index, comments)
            else:
                if self.verbose: print("Error: No gradescale loaded")
                points = None
        else:
            initial_points = next(x.points for x in self.get_comment_list(question_index) if x.comment_string == self.initial_points_str)
            points = initial_points + sum([c.points for c in comments])
            if points < 0: points = 0 #not 0.0, so that it can be checked whether this occurs
        return points
    
    def set_comment_checked(self, comment_str, is_checked, student=None):
        """
        Apply/remove a given comment for the current question to/from a given student. Does nothing if the comment
        string is not found in the list of existing comments.
        
        Args:
            comment_str (string): Description string of the comment to be applied.
            is_checked (bool): If true, apply the comment. If false, remove it.
            student (Student): The student to modify comments for. Defaults to current student.
        """
        if student is None:
            student = self.get_current()
        comment = next(x for x in self.get_comment_list() if x.comment_string == comment_str)
        if is_checked is True:
            student.add_comment(self.question_index, comment)
        else:
            student.remove_comment(self.question_index, comment)
    
    def generate_output_csv(self, mode, input_file=None):
        """
        Generate views of current selection data as CSV files. Files will be saved to a subfolder of the
        current output folder. Detailed descriptions of the options and example output data are shown in the Combine Data
        tab.
        NOTE: Files generated by this method cannot be re-imported! They are intended as human-readable overviews.
        NOTE: Using 'GRADEREPORT' mode and passing an excel file requires the module 'xlrd' to be installed. If the
        import fails, this mode will do nothing.
        
        Args:
            mode (string): The type of output views to generate.
            input_file (string): Path to the file to open. Only used for 'GRADEREPORT' operations. May be an XLSX, XLS
                or CSV file. Excel files are assumed to be of the same form as the 2017 Studienkoordination class grade
                reporting form. CSV files are assumed to contain only the first three columns of the student section of
                the same grade reporting form, without column headers, separated by commas.
        """
        if not os.path.exists(self.output_path_export):
            os.makedirs(self.output_path_export)
        try:
            if mode == 'STUDENTOVERVIEW':
                if self.verbose: print('filteredstudentlist: ', [x.folder for x in self.filtered_student_list])
                for s in self.filtered_student_list:
                    filename = '%s_%s_%s.csv' % (s.folder, s.mat_nr, s.name)
                    path = os.path.join(self.output_path_export, filename)
                    with open(path, 'w') as f:
                        f.write('question,grade,comments\n')
                        for question in range(self.total_questions):
                            comments = s.get_comments(question)
                            if comments:
                                sorted_comments = [c.comment_string for c in sorted(comments, key=attrgetter('comment_string'))]
                                comment_string = '"%s"' % ','.join(map(str, sorted_comments))  # remove quotes around list elements
                            else:
                                comment_string = "-1"
                            points = str(self.get_student_question_score(question, s))
                            f.write('%s,%s,%s\n' % (str(question+1), points, comment_string))
            elif mode == 'CLASSPOINTS':
                filename = "points_students.csv"
                with open(os.path.join(self.output_path_export, filename), 'w') as f:
                    header = '%s' % ','.join(['q' + str(x+1) for x in range(self.total_questions)])
                    f.write('student_folder,%s,total\n' % header)
                    for s in self.filtered_student_list:
                        points = [self.get_student_question_score(q, s) for q in range(self.total_questions)]
                        f.write('%s,%s,%s\n' % (s.folder, ','.join(map(str, points)), sum(points)))
            elif mode == 'CLASSCOMMENTS':
                for question in range(self.total_questions):
                    filename = "comments_overview_q%s.csv" % str(question+1)
                    path = os.path.join(self.output_path_export, filename)
                    with open(path, 'w') as f:
                        f.write("student_folder,comments\n")
                        for s in self.filtered_student_list:
                            comments = s.get_comments(question)
                            if comments:
                                sorted_comments = [c.comment_string for c in sorted(comments, key=attrgetter('comment_string'))]
                                comment_string = '"%s"' % ','.join(map(str, sorted_comments))  # remove quotes around list elements
                            else:
                                comment_string = "-1"
                            f.write('%s,%s\n' % (s.folder, comment_string))
            elif mode == 'GRADEREPORT':
                if input_file is None:
                    if self.verbose: print('Error: Expected valid input file for grade report generation')
                    return
                student_entries = []
                if input_file.endswith('.csv'):
                    """
                    Assume a manually-formatted CSV file containing just the student list section of the grade report excel
                    file, without headers!
                    """
                    with open(input_file, "r") as f:
                        content = [line.rstrip('\n') for line in f]
                        for line in content[1:]:  # ignore first line
                            line_csv = csv.reader([line], skipinitialspace=True)
                            for row in line_csv:
                                student_entries.append([row[0], row[1], row[2]])
                elif input_file.endswith('.xls') or input_file.endswith('.xlsx'):
                    """ Assume a full grade report excel file """
                    try:
                        try:
                            from xlrd import open_workbook
                        except ImportError:
                            if self.verbose: print("Error: Could not import module 'xlrd'. Cancelling operation.")
                            return
                        # load list of student entries from xlsx file (assumed to be in first sheet):
                        sheet = open_workbook(input_file, on_demand=False).sheet_by_index(0) # on_demand=False closes file after reading
                        start = False
                        for row in range(0, sheet.nrows):  # excel displays 1-based row/col numbers, but uses 0-based internally
                            firstval = sheet.cell(row, 0).value
                            if firstval == 'Matr.Nummer': # skip rows until this string appears in the first column, then start reading
                                start = True
                                continue
                            if start:
                                if not firstval: # stop on first row with an empty first column
                                    break
                                student_entries.append([sheet.cell(row, x).value for x in [0, 1, 2]])
                    except (IOError, ValueError) as e:
                        if self.verbose: print(e)
                # find any students for which data is present but do not exist in the xlsx/csv data loaded:
                missing_entries = [s.mat_nr for s in self.student_list if not builtins.any(s.mat_nr in x for x in
                                                                                           [t[0] for t in student_entries])]
                # write output file:
                filename = "reporting_points_overview.csv"
                path = os.path.join(self.output_path_export, filename)
                with open(path, 'w') as f:
                    f.write('student_id,first_name,name,points,name_if_different\n')
                    for s in student_entries:
                        data_student = next((x for x in self.student_list if x.mat_nr in s[0]), None)
                        if data_student:
                            points = str(self.get_student_total_score(data_student))
                            linestring = '%s,%s,%s,%s' % (s[0], s[1], s[2], points)
                            if s[2].lower() != data_student.name.lower():  # check for name difference (ignore case)
                                linestring += ",%s" % data_student.name
                        else:
                            linestring = ','.join(s) + ',XXXX,XXXX'
                        f.write(linestring + '\n')
                    # append the student IDs of any students missing from the input file at the end of the output file:
                    if missing_entries:
                        f.write("\n#### Student IDs missing from input file: ####\n")
                        for s in missing_entries:
                            f.write(s.zfill(12) + '\n') # pad with leading zeros as in xlsx
        except:
            m = 'File writing was not completed, check that '+filename+' is not open in another program'
            QMessageBox.warning(QMessageBox(), 'File writing error', m, QMessageBox.Close)

class FastGrade(QMainWindow, Ui_MainWindow):
    """
    UI Class, provides communication between the UI window and the engine which does the heavy lifting.
    
    Manages enabling/disabling UI components, populating lists, displaying output, creating dialog boxes etc.
    Is responsible ONLY for gui/display related stuff. Data-related stuff goes in FastGradeLightEngine.
    """
    def __init__(self, app):
        QMainWindow.__init__(self)
        Ui_MainWindow.__init__(self)
        self._combine_tab_selected_index = 0
        self.setupUi(self)
        self.engine = FastGradeEngine()
        self.ui_assign_validators()
        self.engine.countChanged.connect(self.ui_on_count_changed) # for load progress bar signalling
        self.ui_set_default_values()
        self.ui_set_default_font()
        self.ui_connect_controls()
        self.ui_lock_controls_by_data()
        self.ui_refresh_all_tabs()
        #import syntax
        #textarea_eval_code
        #highlight = syntax.PythonHighlighter(editor.document())
        
        if self.engine.verbose: print("__init__() completed")
    
    def ui_assign_validators(self):
        """
        Defines regular expression validators to restrict allowed characters for user text inputs.
        
        use these to specify accepted characters for user text input. Strings used in filenames should avoid
        cross-platform reserved characters. Strings written to CSV files should avoid commas, brackets, etc.
        """
        regex_username = QRegExp("[a-zA-Z0-9_.-]+")
        regex_selection_name = QRegExp("[a-zA-Z0-9_.-]+")
        regex_comment_string = QRegExp("[a-zA-Z0-9_.\s-]+")
        self.textbox_init_user.setValidator(QRegExpValidator(regex_username))
        self.textbox_select_selectionName.setValidator(QRegExpValidator(regex_selection_name))
        self.textbox_grading_newComment.setValidator(QRegExpValidator(regex_comment_string))
        
    def ui_connect_controls(self):
        """ Connect signals from UI controls to the appropriate functions """
        
        #self.mainTabs.setFocusPolicy(QtCore.Qt.NoFocus)
        self.installEventFilter(self)
        
        # Connect menu bar actions
        self.actionSave.triggered.connect(self.ui_menu_save)
        self.actionExit.triggered.connect(self.close)
        self.actionRefreshTabs.triggered.connect(self.ui_refresh_all_tabs)
        self.actionZoom_in.triggered.connect(lambda: self.ui_zoom_font(+1))
        self.actionZoom_out.triggered.connect(lambda: self.ui_zoom_font(-1))
        self.actionAbout.triggered.connect(self.ui_show_about)
        
        # connect Init tab controls
        self.button_init_setUser.clicked.connect(self.ui_set_user)
        self.textbox_init_user.returnPressed.connect(self.ui_set_user)
        self.combobox_init_question.currentIndexChanged.connect(self.ui_set_question_nr)
        self.button_init_chooseGradescaleFile.clicked.connect(self.ui_load_gradescale_file)
        self.button_init_initialize.clicked.connect(self.ui_initialize)
        self.combobox_init_dataLoc.currentIndexChanged.connect(self.ui_set_data_location)
        self.button_init_chooseCSVFolder.clicked.connect(self.ui_choose_output_folder)
        self.button_init_loadConfig.clicked.connect(self.ui_load_config_file)
        self.button_init_loadCommentDefs.clicked.connect(self.ui_import_comment_defs_file)
        self.button_init_loadCommentAssignments.clicked.connect(self.ui_import_assignments_file)
        self.checkbox_init_mergeDefs.stateChanged.connect(self.ui_set_import_merge)
        self.checkbox_init_mergeAssign.stateChanged.connect(self.ui_set_import_merge)
        self.checkbox_init_autosave.stateChanged.connect(self.ui_set_autosave)
        self.checkbox_init_autoimport.stateChanged.connect(self.ui_set_autoimport)
        
        # connect Select tab controls
        self.checkbox_select_noComments.stateChanged.connect(self.ui_refresh_select_tab)
        self.checkbox_select_pointsRange.stateChanged.connect(self.ui_refresh_select_tab)
        self.checkbox_select_withComments.stateChanged.connect(self.ui_refresh_select_tab)
        self.checkbox_select_percentage.stateChanged.connect(self.ui_refresh_select_tab)
        self.checkbox_select_invert.stateChanged.connect(self.ui_refresh_select_tab)
        self.spinbox_select_percentage.valueChanged.connect(self.ui_refresh_select_tab)
        self.spinbox_select_pointsFrom.valueChanged.connect(self.ui_refresh_select_tab)
        self.spinbox_select_pointsTo.valueChanged.connect(self.ui_refresh_select_tab)
        self.checkbox_select_onlyCurrentQuestion.stateChanged.connect(self.ui_refresh_select_tab)
        self.button_select_applyRule.clicked.connect(self.ui_update_selection)
        self.button_select_saveRule.clicked.connect(self.ui_save_selection)
        self.button_select_removeRule.clicked.connect(self.ui_remove_selection_rule)
        self.textbox_select_selectionName.textEdited.connect(self.ui_do_select_tab_activation)  # Watches for user to start typing text in the "Selection Rule name" field
        self.button_select_combineAND.clicked.connect(lambda: self.ui_modify_selection('AND'))
        self.button_select_combineOR.clicked.connect(lambda: self.ui_modify_selection('OR'))
        self.button_select_combineEXCEPT.clicked.connect(lambda: self.ui_modify_selection('EXCEPT'))
        self.button_select_resetSelection.clicked.connect(lambda: self.ui_modify_selection('ALL'))
        self.button_select_loadSelection.clicked.connect(self.ui_load_selection)
        self.button_select_commentDifference.clicked.connect(self.ui_comment_diff_selection)
        
        # connect Evaluate tab controls
        self.toolbutton_eval_next.clicked.connect(lambda: self.ui_increment_student('next'))
        self.toolbutton_eval_prev.clicked.connect(lambda: self.ui_increment_student('prev'))
        self.textbox_eval_student.returnPressed.connect(self.ui_set_current_student_folder)
        self.toolbutton_eval_prev.setArrowType(Qt.DownArrow)
        self.toolbutton_eval_next.setArrowType(Qt.UpArrow)
        self.button_evaluate_removeAlternative.clicked.connect(self.ui_remove_alternative_comments)
        
        # connect Grading tab controls
        self.button_grading_addRenameComment.clicked.connect(self.ui_add_comment)
        self.textbox_grading_newComment.returnPressed.connect(self.ui_add_comment)
        self.button_grading_deleteComment.clicked.connect(self.ui_delete_comment)
        self.button_grading_setCommentPoints.clicked.connect(lambda: self.ui_set_comment_points('current'))
        self.button_grading_setInitialPoints.clicked.connect(lambda: self.ui_set_comment_points('initial'))
        self.checkbox_grading_showUnusedOnly.stateChanged.connect(self.ui_refresh_grading_tab_visible_comments)
        self.radio_grading_useSumGrading.toggled.connect(lambda: self.ui_set_grading_mode(self.radio_grading_useSumGrading))
        self.radio_grading_useGradescale.toggled.connect(lambda: self.ui_set_grading_mode(self.radio_grading_useGradescale))
        self.list_grading_comments.itemDoubleClicked.connect(self.ui_grading_clear_selected_comment)
        self.list_grading_comments.itemSelectionChanged.connect(self.ui_grading_show_selected_comment)
        
        # Connect Combine tab controls
        self.combobox_combine_options.currentIndexChanged.connect(self.ui_set_csv_generation_option)
        self.button_combine_generate.clicked.connect(self.ui_perform_selected_csv_operation)
        
        # Short cuts for changing system font size by pressing CTRL+ / CTRL-
        QShortcut(QKeySequence(Qt.CTRL + Qt.Key_Plus), self, lambda: self.ui_zoom_font(+1))
        QShortcut(QKeySequence(Qt.CTRL + Qt.Key_Minus), self, lambda: self.ui_zoom_font(-1))
    
    def ui_set_default_values(self):
        """ Set UI components to show the correct values (hardcoded defaults or loaded data) """
        self.textbox_init_user.setText("")
        if self.engine.user_name:
            self.textbox_init_user.setText(self.engine.user_name)
        
        self.combobox_init_question.clear()
        self.combobox_init_question.addItems([str(x) for x in range(1, self.engine.total_questions + 1)])
        
        self.combobox_init_question.setCurrentIndex(-10)
        if self.engine.get_question_index() is not None:
            self.combobox_init_question.setCurrentIndex(self.engine.get_question_index())
        
        self.label_init_dispBaseFolder.setText("None selected")
        if self.engine.student_data_root:
            self.label_init_dispBaseFolder.setText(self.engine.student_data_root)
        
        self.label_init_dispGradescale.setText("None selected")
        if self.engine.gradescale_path:
            self.label_init_dispGradescale.setText(self.engine.gradescale_path)
        
        self.checkbox_init_autosave.setChecked(self.engine.do_autosave)
        self.checkbox_init_autoimport.setChecked(self.engine.do_autoimport)
        self.checkbox_init_mergeDefs.setChecked(self.engine.merge_DCQs)
        self.checkbox_init_mergeAssign.setChecked(self.engine.merge_ACQs)
        
        self.frame_evaluate_withRemoveButton.hide()
        
        if self.engine.gradescale_path is not None:
            if self.engine.is_using_gradescale() is True:
                self.radio_grading_useGradescale.setChecked(True)
            else:
                self.radio_grading_useSumGrading.setChecked(True)
        else:  # disable gradescale toggle if no gradescale is loaded:
            self.radio_grading_useGradescale.setEnabled(False)
        
        if self.engine.output_path:
            self.label_init_dispCSVFolder.setText(self.engine.output_path)
        
        self.ui_set_csv_generation_option()
        self.ui_refresh_all_tabs()
    
    def ui_set_default_font(self):
        self.app = app
        self.fontSize = self.engine.initial_font_size
        self.app.setFont(QFont("Comic Sans", self.fontSize))
        
    def ui_zoom_font(self, mag):
        """ Change global font size of the application """
        self.fontSize += mag
        self.app.setFont(QFont("Comic Sans", self.fontSize))
        
    def ui_grading_clear_selected_comment(self):
        self.list_grading_comments.clearSelection()
        self.textbox_grading_newComment.setText('')
        
    def ui_grading_show_selected_comment(self):
        self.textbox_grading_newComment.setText('')
        current = self.list_grading_comments.currentItem()
        if current:
            self.textbox_grading_newComment.setText(current.text().split(':')[0])
            
    def ui_add_comment(self):
        """ Create a new comment for the current question, or rename an existing comment if one is selected. """
        selected = self.list_grading_comments.selectedItems()
        #print('selected: ', selected)
        new_text = self.textbox_grading_newComment.text()
        if selected: # rename existing comment
            self.engine.add_rename_comment(new_text, str_to_replace=next(x.text().split(':')[0] for x in selected))
        else: # create new comment
            self.engine.add_rename_comment(new_text)
        self.textbox_grading_newComment.clear()
        self.ui_refresh_grading_comment_list()
        self.ui_refresh_eval_comment_list()
        self.ui_refresh_select_tab_comment_list()
        for i in range(0, self.list_grading_comments.count()): # find and set the new comment as selected
            item = self.list_grading_comments.item(i)
            if new_text in item.text():
                self.list_grading_comments.setCurrentItem(item)
    
    def ui_delete_comment(self):
        """ Remove the selected comment and update display lists. """
        comment_str = self.list_grading_comments.currentItem().text()
        self.engine.delete_comment(comment_str)
        self.ui_refresh_all_tabs()
    
    def ui_set_comment_points(self, mode=None):
        """
        Modify the points assigned for the comment currently selected in list_grading_comments, or the initial points
        assigned for the current question.

        Args:
            mode (str): Use 'initial' to change the initial points, or 'current' to modify the currently selected
            comment.
        """
        if mode == 'initial':
            self.engine.set_initial_points(self.spinbox_grading_initialPoints.value())
            self.ui_refresh_eval_tab()
        elif mode == 'current':
            comment = self.list_grading_comments.currentItem()
            if not comment:
                if self.engine.verbose: print("Cannot modify comment points: No comment selected")
                return
            comment_str = comment.text()
            comment_points = self.spinbox_grading_commentPoints.value()
            self.engine.set_comment_points(comment_str, comment_points)
            self.ui_refresh_grading_comment_list()
            self.ui_refresh_eval_comment_list()
            self.ui_refresh_select_tab_comment_list()
    
    def ui_increment_student(self, step='next'):
        """
        Select the previous/next student in the current selection. Wraps to the start/end if the last/first student
        was reached.
        
        Args:
            step (str): Options are 'next' and 'prev'. Defaults to 'next'
        """
        self.engine.increment_student(step)
        self.ui_refresh_eval_tab()
    
    def ui_set_current_student_folder(self):
        """
        Called when a folder number is entered into the text box and Enter is pressed. Attempts to set the current
        student to the one who's folder name was typed in the box (assuming that folder both exists and is present
        in the current selection).
        """
        folder_name = self.textbox_eval_student.text()
        self.engine.set_current_student_by_folder(folder_name)
        self.ui_refresh_eval_tab()
    
    def ui_refresh_init_tab(self):
        """
        Update UI element text/display (not enabled state!) in Initialize tab based on engine state.
        
        Note: button_init_initialize and button_init_loadCommentDefs are handled in ui_lock_controls_by_data()
        """
        if self.engine.student_data_root:
            self.label_init_dispBaseFolder.setText(self.engine.student_data_root)
        else:
            self.label_init_dispBaseFolder.setText("None selected")
        if self.engine.output_path:
            self.label_init_dispCSVFolder.setText(self.engine.output_path)
        else:
            self.label_init_dispCSVFolder.setText("None selected")
        if self.engine.gradescale_path:
            self.label_init_dispGradescale.setText(self.engine.gradescale_path)
        else:
            self.label_init_dispGradescale.setText("None selected")
        if self.engine.has_required_info():
            self.label_init_status.setText("Status: Config loaded")
        else:
            self.label_init_status.setText("Status: Missing required config data")
        if self.engine.get_full_student_list():
            self.label_init_status.setText("Status: Ready")
    
    def ui_refresh_select_tab(self):
        """ Updates UI display elements in the Select Tab. """
        self.ui_refresh_select_tab_comment_list()
        self.ui_refresh_select_tab_available_selections()
        self.ui_refresh_select_tab_student_list()
        self.ui_do_select_tab_activation()
        total_count = str(len(self.engine.get_full_student_list()))
        sel_count = str(len(self.engine.get_filtered_student_list()))
        self.groupbox_select_currentSelection.setTitle("Currently selected students: %s / %s" % (sel_count, total_count))
    
    def ui_refresh_grading_tab(self):
        """ Updates UI display elements in the Grading Tab. """
        self.ui_refresh_grading_comment_list()
        self.ui_refresh_grading_tab_visible_comments()
        if self.engine.gradescale_path:
            self.radio_grading_useGradescale.setEnabled(True)
        self.textbox_grading_newComment.setText('')
    
    def ui_refresh_eval_tab(self):
        """ Updates UI display elements in the Evaluate Tab. Retains scrollbar positions """
        scrollvalues = (
            self.textarea_eval_code.verticalScrollBar().value(),  # store current scroll position
            self.textarea_eval_output.verticalScrollBar().value(),
            self.textarea_eval_expected.verticalScrollBar().value(),
            self.textarea_eval_analysis.verticalScrollBar().value()
        )
        
        self.textarea_eval_code.setText(self.engine.get_current('SCRIPTCODE'))
        self.textarea_eval_output.setText(self.engine.get_current('SCRIPTOUTPUT'))
        expected, analysis = self.engine.get_current('SCRIPTANALYSIS')
        self.textarea_eval_expected.setText(expected)
        self.textarea_eval_analysis.setText(analysis)
        
        self.textarea_eval_code.verticalScrollBar().setValue(scrollvalues[0]) # go back to scroll position after update
        self.textarea_eval_output.verticalScrollBar().setValue(scrollvalues[1])
        self.textarea_eval_expected.verticalScrollBar().setValue(scrollvalues[2])
        self.textarea_eval_analysis.verticalScrollBar().setValue(scrollvalues[3])
        
        student = self.engine.get_current()
        if student:
            self.textbox_eval_student.setText(student.folder)
        
        #Version with blocked student name
        if self.engine.get_current('FILENAME'):
            self.label_eval_dispCurrentFile.setText(self.engine.get_current('FILENAME')[:11]+'...(blocked student name)')
        else:
            self.label_eval_dispQuestion.setText(str(self.engine.get_question_index() + 1))
        #Version with student name
        #self.label_eval_dispCurrentFile.setText(self.engine.get_current('FILENAME'))
        
        self.label_eval_dispQuestion.setText(str(self.engine.get_question_index() + 1))
        
        plot = self.engine.get_current('PLOT')
        if plot:
            img = QPixmap()
            img.loadFromData(plot)
            self.label_eval_imageSpace.setPixmap(img)
            self.label_eval_imageSpace.setScaledContents(True)
            self.label_eval_imageSpace.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)
        else:
            self.label_eval_imageSpace.setText('-- No Image --')

        self.ui_refresh_grading_comment_list()
        self.ui_refresh_eval_comment_list()
        self.ui_refresh_select_tab_comment_list()
        points = self.engine.calculate_student_points()
        if self.engine.verbose: print("Student points: ", points)
        if points is None:
            # may occur if not gradescale file set, or if a valid gradescale script returns a None value, e.g. if
            # no comments were checked but at least one must be selected.
            self.label_eval_dispPoints.setText("Score or grade scheme undefined")
        else:
            self.label_eval_dispPoints.setText(str(points))
        total_count = str(len(self.engine.get_full_student_list()))
        sel_count = str(len(self.engine.get_filtered_student_list()))
        self.label_eval_dispStatus.setText('%s / %s students selected' % (sel_count, total_count))
    
    def ui_refresh_all_tabs(self):
        """ Refresh UI elements in all relevant tabs. Does not un/lock tabs & controls based on engine state! """
        self.ui_refresh_init_tab()
        self.ui_refresh_select_tab()
        self.ui_refresh_eval_tab()
        self.ui_refresh_grading_tab()
    
    def ui_refresh_grading_comment_list(self):
        """ Refresh the list of comments shown in Grading tab, including separate entry for initial points comment. """
        self.list_grading_comments.clear()  # clear select list
        self.textbox_grading_newComment.setText('')
        for x in self.engine.get_comment_list():
            if x.comment_string == self.engine.initial_points_str:  # Handle initial points/gradescale comment separately
                if self.engine.is_using_gradescale():  # show gradescale path instead of comment text
                    comment_item = QListWidgetItem("Gradescale file: " + self.engine.gradescale_path)
                else:  # show initial points value
                    comment_item = QListWidgetItem('%s:\t%s' % (self.engine.initial_points_str, str(x.points)))
                comment_item.setFlags(QtCore.Qt.NoItemFlags)
            else:
                comment_item = QListWidgetItem('%s:\t%s' % (x.comment_string, str(x.points)))
            self.list_grading_comments.addItem(comment_item)
        #self.list_grading_comments.sortItems() #removed by tinri, since this did not work well and sorting is now in get_comment_list()

    
    def ui_refresh_grading_tab_student_list(self):
        """ Update UI display list of loaded student folders in the Grading tab."""
        self.list_grading_selection.clear()
        for student in self.engine.get_filtered_student_list():
            self.list_grading_selection.addItem(QListWidgetItem(student.folder))
    
    def ui_refresh_grading_tab_visible_comments(self):
        """
        Toggles which comments are visible in the list in Grading tab. Unused comments are ones which are not checked for
        any student files.
        The "Initial points" entry is only shown when using sum grading, and is always greyed out (can't be selected for
        modification). It's point value can still be modified via the appropriate spin box.
        """
        self.list_grading_comments.clear()
        if self.checkbox_grading_showUnusedOnly.isChecked():  # show only comments not present in any student object
            visible_comments = [x for x in self.engine.get_comment_list() if
                                x not in self.engine.get_comment_list_in_use() and
                                x.comment_string != self.engine.initial_points_str]
            self.button_grading_deleteComment.setEnabled(True)
            if self.engine.verbose: print("Showing only unused comments")
        else:
            visible_comments = self.engine.get_comment_list()
            self.button_grading_deleteComment.setEnabled(False)
            if self.engine.verbose: print("Showing all comments")
        for x in visible_comments:
            if x.comment_string == self.engine.initial_points_str:  # initial points is always selected -> make a label instead of checkbox
                if self.engine.is_using_gradescale():  # show gradescale path instead of sum grading
                    comment = QLabel("Gradescale file: " + self.engine.gradescale_path)
                else:  # show initial points value
                    comment = QLabel('%s:\t%s' % (self.engine.initial_points_str, str(x.points)))
                comment_item = QListWidgetItem(comment.text())
                comment_item.setFlags(QtCore.Qt.NoItemFlags)
                self.list_grading_comments.addItem(comment_item)
            else:
                comment_item = QListWidgetItem('%s:\t%s' % (x.comment_string, str(x.points)))
                self.list_grading_comments.addItem(comment_item)
    
    def ui_refresh_eval_comment_list(self):
        """
        Refresh the checkbox list on Evaluate tab to show all currently existing comments, as well as a default
        non-interactive entry indicating whether sum grading or gradescale is selected, and the initial point value or
        gradescale file path as appropriate. Adds dynamic signalling to the checkbox widgets. Includes alternative
        evaluation, if present.
        """
        for i in reversed(range(self.verticallayout_eval_comment.count() - 1)):  # clear checkboxes from Evaluate list
            self.verticallayout_eval_comment.itemAt(i).widget().setParent(None)
        question_nr = self.engine.get_question_index()
        student = self.engine.get_current()
        
        # sort list manually since qvboxlayout can't handle that. Move initial points comment to the top of the list
        comment_list = sorted(self.engine.get_comment_list(), key=lambda k: k.comment_string) # sort list alphabetically
        comment_list.insert(0, comment_list.pop(comment_list.index(
                next(x for x in comment_list if x.comment_string == self.engine.initial_points_str))))
        
        # Populate checkbox list:
        for x in comment_list:
            if x.comment_string == self.engine.initial_points_str:  # initial points is always selected -> make a label instead of checkbox
                if self.engine.is_using_gradescale():  # show gradescale path instead of sum grading
                    comment = QLabel("Gradescale file: " + self.engine.gradescale_path)
                else:  # show initial points value
                    comment = QLabel('%s:\t%s' % (self.engine.initial_points_str, str(x.points)))
                self.verticallayout_eval_comment.insertWidget(self.verticallayout_eval_comment.count() - 1, comment)
            else:
                alternative_evaluation_string = ''
                if self.engine.alternative_evaluation_present:
                    if student and x in student.get_comments(question_nr, comment_type = 'alternative'):
                        alternative_evaluation_string = self.engine.alternative_evaluation_checked_str
                    else:
                        alternative_evaluation_string = self.engine.alternative_evaluation_unchecked_str
                comment = QCheckBox(alternative_evaluation_string+x.comment_string)
                if student and x in student.get_comments(question_nr):
                    comment.setChecked(True)
                comment.stateChanged.connect(functools.partial(self.ui_set_checked_comment, comment))  # add dynamic signalling
                self.verticallayout_eval_comment.insertWidget(self.verticallayout_eval_comment.count() - 1, comment)
    
    def ui_refresh_select_tab_comment_list(self):
        """
        Refresh the checkbox list on Select tab to show all currently existing comments. No entry is shown for the
        default initial points comment.
        Does not add dynamic signalling to the checkbox widgets - widget state is only used as an indicator when
        button_select_saveRule is clicked. Checking a comment does nothing by itself.
        The list displays all comments for ALL questions, each with a prefix showing which question it applies to.
        Example: "(2): Correct"
        """
        layout = self.verticallayout_select_withComments
        items = [layout.itemAt(i) for i in range(layout.count())]
        checked_comments = [k for k in [w.widget() for w in items] if isinstance(k, QCheckBox) and k.isChecked()]
        if self.engine.verbose: 
            print('checked comments: ', [x.text() for x in checked_comments])
        
        for i in reversed(range(self.verticallayout_select_withComments.count() - 1)):  # clear checkboxes from Evaluate list
            self.verticallayout_select_withComments.itemAt(i).widget().setParent(None)
        # filter_comments = self.engine.filter.with_comment_list
        # if filter_comments is None:
        #     filter_comments = []
        # for x in [k for k in self.engine.get_comment_list('ALL') if k.comment_string != self.engine.initial_points_str]:
        #         comment = QCheckBox('(%s): %s' % (str(x.question+1), x.comment_string))
        #         if x in filter_comments:
        #             comment.setChecked(True)
        #         comment.stateChanged.connect(self.ui_refresh_select_tab)  # add dynamic signalling
        #         self.verticallayout_select_withComments.insertWidget(self.verticallayout_select_withComments.count()-1, comment)
        #filter_comments = self.engine.filter.with_comment_list
        #if filter_comments is None:
        #    filter_comments = []
        for x in [k for k in self.engine.get_comment_list('ALL') if k.comment_string != self.engine.initial_points_str]:
                comment = QCheckBox('(%s): %s' % (str(x.question+1), x.comment_string))
                if comment.text() in [c.text() for c in checked_comments]:
                    comment.setChecked(True)
                comment.stateChanged.connect(self.ui_refresh_select_tab)  # add dynamic signalling
                self.verticallayout_select_withComments.insertWidget(self.verticallayout_select_withComments.count()-1, comment)
    
    def ui_refresh_select_tab_available_selections(self):
        """
        Refresh the list of available selections in Select tab
        Refreshed list will show all selections from appropriately named files found in the current directory.
        """
        files = glob.glob(os.path.join(self.engine.output_path_selection, 'selection_*.csv'))
        files = [os.path.basename(x) for x in files]
        names = [f[10:-4] for f in files] # trim filenames to selection name
        self.list_select_availableSelections.clear()
        for name in sorted(names):
            self.list_select_availableSelections.addItem(QListWidgetItem(name))
        
    def ui_refresh_select_tab_student_list(self):
        """ Refresh the list of selected student folders in Select tab """
        self.list_select_currentlySelected.clear()  # clear select list
        if self.engine.verbose: print('filtered list:',[x.folder for x in self.engine.get_filtered_student_list()])
        for x in sorted(self.engine.get_filtered_student_list()):
            self.list_select_currentlySelected.addItem(QListWidgetItem(x.folder))
        
    def ui_do_select_tab_activation(self):
        """ Updates enabled/disabled controls in select tab based on checkboxes. """
        checked = self.checkbox_select_pointsRange.isChecked()
        self.spinbox_select_pointsFrom.setEnabled(checked)
        self.label_select_to.setEnabled(checked)
        self.spinbox_select_pointsTo.setEnabled(checked)
        self.checkbox_select_onlyCurrentQuestion.setEnabled(checked)
        
        self.scrollarea_select_withComments.setEnabled(self.checkbox_select_withComments.isChecked())
        checked = self.checkbox_select_percentage.isChecked()
        self.spinbox_select_percentage.setEnabled(checked)
        if self.textbox_select_selectionName.text():
            self.button_select_saveRule.setEnabled(True)
        else:
            self.button_select_saveRule.setEnabled(False)
        if self.list_select_availableSelections.currentItem() is not None:
            self.button_select_removeRule.setEnabled(True)
        else:
            self.button_select_removeRule.setEnabled(False)
        if self.list_select_availableSelections.count() > 0:
            self.button_select_removeRule.setEnabled(True)
        else:
            self.button_select_removeRule.setEnabled(False)
    
    def ui_set_checked_comment(self, check_widget):
        """
        Called when a comment checkbox in Evaluate tab is un/checked. Records appropriate comment
        selection for the current student and question.
        After this call, all comments are shown in the Grading tab, even if showUnusedOnly was previously checked.
        """
        
        #If alternative evaluation is present, the comment in the grading tab is preceeded by the alternative grading.
        #Therefore, in this case the widget text is no longer the same as the comment text.
        #This is compensated for here.
        if self.engine.alternative_evaluation_present:
            comment_str = check_widget.text()[len(self.engine.alternative_evaluation_checked_str):]
        else:
            comment_str = check_widget.text()
        
        self.engine.set_comment_checked(comment_str, check_widget.isChecked())
        self.checkbox_grading_showUnusedOnly.setChecked(False)
        self.ui_refresh_eval_tab()
        hbar = self.scrollarea_eval_comment.horizontalScrollBar()
        hbar.setValue(hbar.minimum())
        
        
    def ui_remove_alternative_comments(self):
        """
        Deletes all alternative assigned comments and hides the botton for removing the alternative evaluation (evaluate tab).
        """
        self.engine.clear_alternative_comments()
        self.engine.alternative_evaluation_present = False
        self.frame_evaluate_withRemoveButton.hide()
        self.ui_refresh_eval_tab()
    
    def ui_load_gradescale_file(self):
        """ Open a file dialog to select the gradescale file to use. The file is not read/executed until required. """
        file = self.ui_choose_single_file("Python Files (*.py)", "Python Files (*.py)", self.engine.script_folder)
        if file:
            self.engine.gradescale_path = file
            self.ui_refresh_all_tabs()
    
    def ui_set_question_nr(self):
        """ Sets the current question being worked on. """
        self.engine.set_question_nr(int(self.combobox_init_question.currentIndex()))
        self.label_eval_dispQuestion.setText(str(self.engine.get_question_index() + 1))
        self.ui_lock_controls_by_data()
    
    def ui_set_user(self):
        """ Sets the current username. """
        self.engine.user_name = self.textbox_init_user.text()
        self.ui_lock_controls_by_data()

    def ui_load_config_file(self):
        """ Open a file chooser to select a config file to import. """
        file = self.ui_choose_single_file("Pickle Files (*.pkl)", "Pickle Files (*.pkl)", self.engine.script_folder)
        if file:
            self.engine.load_config(file)
            self.ui_refresh_init_tab()
    
    def ui_set_data_location(self):
        """ Sets the student data location. Opens file/folder chooser as appropriate """
        index = self.combobox_init_dataLoc.currentIndex()
        if index == 0:  # load data folder
            folder = self.ui_choose_directory(self.engine.script_folder)
            if folder:
                self.engine.set_student_data_root_folder(folder)
                self.ui_refresh_init_tab()
                self.ui_lock_controls_by_data()
        elif index == 1: # load data file
            file = self.ui_choose_single_file("Pickle Files (*.pkl)", "Pickle Files (*.pkl)", self.engine.script_folder)
            if file:
                self.engine.load_student_data_file(file)
                self.ui_refresh_init_tab()
        # Reset the combobox so that re-using the last location type is immediately available again:
        self.combobox_init_dataLoc.setCurrentIndex(-1)
    
    def ui_choose_output_folder(self):
        """ Open a folder dialog to select the directory to save CSV files into. """
        folder = self.ui_choose_directory(self.engine.script_folder)
        if folder:
            self.engine.set_output_folder(folder)
            self.ui_refresh_init_tab()
    
    def ui_import_comment_defs_file(self):
        """ Open a file chooser to select a comment definition file to import """
        file = self.ui_choose_single_file("CSV Files (*.csv)", "CSV Files (*.csv)", self.engine.output_path)
        if file:
            self.engine.import_DCQ(file, self.engine.merge_DCQs)
            self.ui_refresh_grading_comment_list()
            self.ui_refresh_eval_comment_list()
            self.ui_refresh_select_tab_comment_list()
            self.ui_refresh_grading_tab_visible_comments()
    
    def ui_import_assignments_file(self):
        """ Open a file chooser to select a comment assignment file to import """
        file = self.ui_choose_single_file("CSV Files (*.csv)", "CSV Files (*.csv)", self.engine.output_path)
        if file:
            self.engine.import_ACQ(file, self.engine.merge_ACQs)
            self.ui_refresh_grading_comment_list()
            self.ui_refresh_eval_comment_list()
            self.ui_refresh_select_tab_comment_list()
            self.ui_refresh_grading_tab_visible_comments()
    
    def ui_set_import_merge(self):
        """
        Toggle merging/overwriting options for DCQ and ACQ files. If merging is enabled, loading files of that type will
        merge the loaded data into the existing data structure instead ov overwrinting it. Intended to allow merging
        of multiple DCQ/ACQ files for the same question, or combining data from files for individual questions to
        obtain whole-class datastructures for final reporting etc.
        """
        self.engine.merge_DCQs = self.checkbox_init_mergeDefs.isChecked()
        self.engine.merge_ACQs = self.checkbox_init_mergeAssign.isChecked()
    
    def ui_set_csv_generation_option(self):
        """
        Update the description shown in the Combine tab text area when a new CSV operation is selected from the
        associated combobox
        """
        text = ""
        self._combine_tab_selected_index = self.combobox_combine_options.currentIndex()
        if self._combine_tab_selected_index == 0:  # "Generate student overview files"
            text = """Description:
------------
For each student in the current selection, write a CSV file named "<studentFolder>_<studentNr>_<studentName>.csv" \
containing the point scores and comments currently assigned with that student for all question numbers.
Only student files to which the current selection rule applies will be processed.
    
File(s) generated will be saved in a subfolder (default: "overview") of the current output folder. Existing files with \
the same name(s) will be overwritten.

The first line in the file contains the labels for each column of data. Subsequent lines each contain a single record.
If no comments have been checked for a given file, the comments column will contain '-1'. If multiple comments have \
been checked, they will be separated by commas.
    
Example file contents:
----------------------
    
question,grade,comments
1,10.0,-1
2,2.0,"incorrect solution,output is missing"
3,10.0,correct solution
4,0.0,empty file
5,10.0,correct solution
6,10.0,correct solution
7,10.0,correct solution
8,2.0,"incorrect solution,wrong output"
9,2.0,"incorrect solution,infinite loop, output is missing"
10,2.0,"incorrect solution,output is missing"
"""
        elif self._combine_tab_selected_index == 1:  # "Generate class points overview file"
            text = """Description:
------------
Generates a CSV file named "points_students.csv" containing an overview of the points each student received for each \
question. Only student files to which the current selection rule applies will be processed.
    
File(s) generated will be saved in a subfolder "overview" of the current output folder. Existing files with the \
same name(s) will be overwritten.

The first line in the file contains the labels for each column of data. Subsequent lines each contain a single record.

Example file contents:
----------------------

student_folder,q1,q2,q3,q4,q5,q6,q7,q8,q9,q10,total
123456,5.0, 3.0, 10.0, 10.0, 8.0, 9.5, 5.0, 5.0, 10.0,10.0, 75.5
123457,10.0, 10.0, 10.0, 10.0, 8.0, 10.0, 10.0, 10.0, 10.0,10.0, 98.0
123458,2.0, 2.0, 2.0, 2.0, 2.0, 0.0, 0.0, 0.0, 5.0,5.0, 20.0
"""
        elif self._combine_tab_selected_index == 2:  # "Generate class comments overview files"
            text = """Description:
------------
Generates files named "comments_overview_q<question>.csv" for each question number, containing a list of comments \
(as human-readable strings) assigned to students for the corresponding question. Only student files to which the \
current selection rule applies will be processed.

File(s) generated will be saved in a subfolder (default: "overview") of the current output folder. Existing files with \
the same name(s) will be overwritten.

The first line in the file contains the labels for each column of data. Subsequent lines each contain a single record.
If no comments have been checked for a given student, the comments column will contain '-1'.

Example file contents:
----------------------

student_folder,comments
123456,"correct"
123457,"incorrect,infinite loop"
123458,"incorrect,divide by zero,no output"
123459,-1
"""
        elif self._combine_tab_selected_index == 3:  # "Generate grade report formatted class overview file"
            text = """Description:
------------
Generates a file called "reporting_points_overview.csv" containing student data formatted as required for the grade \
submission form. Opens a dialog to select an Excel or CSV file to be used as reference. Generated data will be ordered as in \
the XLS file, including leading zeros in the student ID column. The output file contains data taken both from the \
given XLS file (student id, first and last names), as well as internal grading data (points). If the student name \
loaded from the file does not match the name in internal data, the internal name will be added in an additional \
column. Name comparison ignores capialization.

Students which are present in the input file but have not been graded (i.e. no points value or name defined) will be \
marked with 'XXXX' as a visual indicator
If there are students with IDs which were not found in the input file, a list of  missing student IDs will be added at \
the bottom of the file after a separator. All loaded students will be processed, the current selection has no \
influence on this operation.


NOTE: This function makes several asumptions about the structure of the file to load. It is written to work with \
the 2016 version of the UZH grade reporting XLSX file. Using it with files that do not match this structure may \
produce unexpected results! If a CSV file is selected, it is assumed to contain the first three columns of the student \
data section of the same grade report XLSX file, with values separated by commas, and no column headers!

File(s) generated will be saved in a subfolder (default: "overview") of the current output folder. Existing files with \
the same name(s) will be overwritten.

Example file contents:
----------------------

student_id,first_name,name,points,name_if_different
000017843920,Albert,Einstein,78.0
000012493993,Max,Müller,23.5,mueller
000015921748,Marie,Curie,66.0
000011087234,Simon,Laplace,42.5

#### Student IDs missing from input file: ####
000014690004
000009071239
000017589344
"""
        self.textarea_combine_description.setText(text)
    
    def ui_perform_selected_csv_operation(self):
        """ Run the CSV file operation selected in the Combine tab combobox """
        if self._combine_tab_selected_index == 0:  # "Generate student overview files"
            self.engine.generate_output_csv('STUDENTOVERVIEW')
        elif self._combine_tab_selected_index == 1:  # "Generate class points overview file"
            self.engine.generate_output_csv('CLASSPOINTS')
        elif self._combine_tab_selected_index == 2:  # "Generate class comments overview files"
            self.engine.generate_output_csv('CLASSCOMMENTS')
        elif self._combine_tab_selected_index == 3:  # "Generate grade report formatted class overview file"
            file = self.ui_choose_single_file("Excel Files (*.xlsx *.xls);;CSV Files (*.csv)", "Excel Files (*.xlsx *.xls)", self.engine.output_path)
            self.engine.generate_output_csv('GRADEREPORT', file)
    
    def ui_set_grading_mode(self, widget):
        """
        Set the grading mode (point sum / gradescale) to be used.
        
        Args:
            widget: The widget who's signal is connected to this function. Should be a radio button.
        """
        if widget == self.radio_grading_useSumGrading and widget.isChecked() is True:
            self.engine.using_gradescale = False
        if widget == self.radio_grading_useGradescale and widget.isChecked() is True:
            self.engine.using_gradescale = True
        self.ui_refresh_eval_tab()
    
    @staticmethod
    def ui_choose_directory(start_dir=os.path.dirname(os.path.realpath(__file__))):
        """
        Open dialog window to select a folder, starting in a specified folder.
        
        Args:
            start_dir (string): The folder to open the dialog in. Default is the folder containing this file.
        
        Returns:
         Folder path as string, or None if the user pressed cancel/close
        """
        return QFileDialog.getExistingDirectory(QFileDialog(), "Select Directory", start_dir)

    @staticmethod
    def ui_choose_single_file(file_filters, selected_filter,
                              start_dir=os.path.dirname(os.path.realpath(__file__))):
        """
        Open dialog window to select a single file, starting in a specified folder.

        Args:
            file_filters (string): List of file extension strings, used to matches selectable files. Example:
                "fileFilters = "Python Files (*.py);;Text Files (*.txt);;All Files (*)"
            selected_filter (string): A string present in file_filters, used as the default file matches. Example:
                "Text Files (*.txt)"
            start_dir (string): The folder to open the dialog in. Default is the folder containing this file.
        
        Returns:
            File full path as string, or None if the user pressed cancel/close
        """
        file_name, _ = QFileDialog.getOpenFileName(QFileDialog(), "Select File", start_dir, file_filters, selected_filter)
        return file_name

    @staticmethod
    def ui_choose_multiple_files(file_filters, selected_filter,
                                 start_dir=os.path.dirname(os.path.realpath(__file__))):
        """
        Open dialog window to select one or more files, starting in a specified folder.
        
        Args:
            file_filters (string): List of file extension strings, used to matches selectable files. Example:
                "fileFilters = "Python Files (*.py);;Text Files (*.txt);;All Files (*)"
            selected_filter (string): A string present in file_filters, used as the default file matches. Example:
                "Text Files (*.txt)"
            start_dir (string): The folder to open the dialog in. Default is the folder containing this file.

        Returns:
            List of file full paths as strings, or None if the user pressed cancel/close
        """
        files, _ = QFileDialog.getOpenFileNames(QFileDialog(), "Select Files", start_dir, file_filters, selected_filter)
        return files
    
    @staticmethod
    def ui_save_file_as(file_filters, selected_filter, default_filename=None,
                        start_dir=os.path.dirname(os.path.realpath(__file__))):
        """
        Open dialog window to save a file, starting in a specified folder.
        
        Args:
            file_filters (string): List of file extension strings, used to matches selectable files. Example:
                "fileFilters = "Python Files (*.py);;Text Files (*.txt);;All Files (*)"
            selected_filter (string): A string present in file_filters, used as the default file matches. Example:
                "Text Files (*.txt)"
            default_filename (string): Default filename to suggest. Should only be the filename itself (without path).
                Example: path = "output.txt"
            start_dir (string): The folder to open the dialog in. Default is the folder containing this file.
        
        Returns:
            File full path as string, or None if the user pressed cancel/close
        """
        file_name, _ = QFileDialog.getSaveFileName(QFileDialog(), "Save As", start_dir + default_filename, file_filters, selected_filter)
        return file_name
    
    def ui_lock_controls_by_data(self):
        """
        Disables some Init tab controls unless all data required to initialize the engine is provided.
        Disables all other tabs unless this data was provided and student files have also been loaded.
        Disables all tabs except Init (and some Init tab controls) unless all required data has been entered
        """
        enabled = self.engine.has_required_info()
        self.button_init_initialize.setEnabled(enabled)
        self.button_init_loadCommentDefs.setEnabled(enabled)
        self.checkbox_init_mergeDefs.setEnabled(enabled)
        
        enabled = self.engine.has_loaded_student_data()
        self.button_init_loadCommentAssignments.setEnabled(enabled)
        self.button_init_loadCommentDefs.setEnabled(enabled)
        self.checkbox_init_mergeAssign.setEnabled(enabled)
        self.checkbox_init_mergeDefs.setEnabled(enabled)
        self.tab_select.setEnabled(enabled)
        self.tab_eval.setEnabled(enabled)
        self.tab_grading.setEnabled(enabled)
        self.tab_combine.setEnabled(enabled)
        self.ui_refresh_all_tabs()
        if enabled: # update progress bar as visual indicator that student data needs reloading
            self.progressbar_init_status.setMaximum(100)
            self.progressbar_init_status.setValue(100)
        else:
            self.progressbar_init_status.setMaximum(100)
            self.progressbar_init_status.setValue(0)
            self.label_init_status.setText("Status: Config loaded")
    
    def ui_initialize(self):
        """
        Initialize the engine, load student files and refresh ui displays once all required data is present.
        Does nothing if required data is missing.
        """
        if self.engine.has_required_info():
            self.engine.initialize_system()
            self.ui_lock_controls_by_data()
            self.ui_refresh_all_tabs()
    
    def ui_save_selection(self):
        """ Save the current selection to file without recalculating anything. """
        if not self.textbox_select_selectionName.text():
            if self.engine.verbose: print("Error: Cannot process unnamed selection rule")
            return
        self.engine.save_sel_file(self.textbox_select_selectionName.text())
        self.ui_refresh_select_tab_available_selections()
    
    def ui_update_selection(self):
        """
        Uses the parameters set in the Define Selection Rule section of Select tab to update the selection filter, then
        updates the current list of selected students and saves this list as a selection file. The new file will be
        added to the list of Available Selections in Select tab.
        Called when Save Current Selection is clicked in Select tab.
        """
        rule = Filter()
        if self.checkbox_select_noComments.isChecked():
            rule.set_constraint_with_no_comments(True)
        if self.checkbox_select_pointsRange.isChecked():
            low = self.spinbox_select_pointsFrom.value()
            high = self.spinbox_select_pointsTo.value()
            rule.set_constraint_in_point_range(low, high)
        if self.checkbox_select_withComments.isChecked():
            checked_list = []
            layout = self.verticallayout_select_withComments
            items = (layout.itemAt(i) for i in range(layout.count()))
            
            for widget in [x.widget() for x in items]:
                if isinstance(widget, QCheckBox) and widget.isChecked():
                    sections = widget.text().split("): ")
                    checked_list.append((int(sections[0][1:])-1, sections[1]))  # ignore question prefix
            if checked_list:
                comment_list = [x for x in self.engine.get_comment_list('ALL') if
                                (x.question, x.comment_string) in checked_list]
                rule.set_constraint_with_comments(comment_list)
        if self.checkbox_select_percentage.isChecked():
            rule.set_constraint_rnd_percentage(self.spinbox_select_percentage.value())
        if self.checkbox_select_invert.isChecked():
            rule.set_inverted(True)
        if self.checkbox_select_onlyCurrentQuestion.isChecked():
            rule.set_only_current_question(True)
        self.engine.filter = rule # Apply new rule
        self.engine.apply_filter()
        self.engine.save_sel_file()
        self.ui_refresh_select_tab()
        self.ui_refresh_eval_tab()
    
    def ui_remove_selection_rule(self):
        """
        Delete the selected rule(s) from the Available Selections list in Select tab. Does not affect the current
        selection. Deletes the files associated with the selected rules (if found) and refreshes the list of available
        selections. Does nothing if no lines are selected.
        """
        names_to_delete = [str(x.text()) for x in self.list_select_availableSelections.selectedItems()]
        for line in names_to_delete:
            filename = os.path.join(self.engine.output_path_selection, 'selection_%s.csv' % line)
            try:
                os.remove(filename)
                if self.engine.verbose: print('Deleted file:', filename)
            except OSError:
                if self.engine.verbose: print('Error: Cannot delete missing file:', filename)
        self.ui_refresh_all_tabs()
    
    def ui_modify_selection(self, mode):
        """
        Modify the current list of selected students based on the chosen selection files in list_select_availableSelections.
        Saves the modified selection under the current selection name, with a suffix appended describing the mode used
        to generate the slection and which other selections were involved.

        Args:
            mode (str): Signifies which type of modification to perform. Options are:
                'AND' (logical AND between current selection and all students in chosen selections),
                'OR' (logical OR between current selection and all students in chosen selections),
                'EXCEPT' (exclude all students in chosen selections from the current selection),
                'ALL' (reset current selection to include all students)
        """
        selection_names = [str(x.text()) for x in self.list_select_availableSelections.selectedItems()]
        self.engine.modify_selection(mode, selection_names)
        if mode == 'ALL':
            self.checkbox_select_invert.setChecked(False)
            self.checkbox_select_percentage.setChecked(False)
            self.checkbox_select_pointsRange.setChecked(False)
            self.checkbox_select_noComments.setChecked(False)
            self.checkbox_select_withComments.setChecked(False)
            self.textbox_select_selectionName.clear()
        else:
            self.engine.save_sel_file()
        self.ui_refresh_all_tabs()
    
    def ui_comment_diff_selection(self):
        """
        Opens a file dialog to select an ACQ file, and modifies the current selection to show only those students which
        were present in the selection, AND have comment assignments which are not identical to the assignments
        loaded from the file. If the file contains assignments for students which are not present in the current
        selection, the associated file data is ignored. Comment assignments in the file with IDs which do not match any
        of the currently loaded/imported comments are ignored.
        Assigns the alternative comment assignments from the selected ACQ file to all students in the ACQ file
        (and shows a bottom to remove these in the evaluation part). Any existing alternative comments are removed first.
        """
        acq_file = self.ui_choose_single_file("CSV Files (*.csv)", "CSV Files (*.csv)", self.engine.script_folder)
        if acq_file:
            self.engine.do_comment_diff_selection(acq_file)
            self.engine.import_ACQ(acq_file, merge=False, comment_type = 'alternative')
            self.frame_evaluate_withRemoveButton.show()
            self.engine.alternative_evaluation_present = True
            self.ui_refresh_all_tabs()
    
    def ui_load_selection(self):
        """
        Load a selection file from a given selection name and replace the current selection with it.
        Sets the text in textbox_select_selectionName to the given selsection name.
        """
        selections = self.list_select_availableSelections.selectedItems()
        if not selections:
            if self.engine.verbose: print("Error: No items selected.")
            return
        if len(selections) > 1:
            if self.engine.verbose: print("Warning: Multiple items selected. Only the first item in list will be loaded.")
        sel_name = selections[0].text()
        self.engine.import_sel(sel_name)
        self.textbox_select_selectionName.setText(sel_name)
        self.ui_refresh_all_tabs()
    
    def ui_on_count_changed(self, value):
        """
        Update the progress bar on Init tab when the engine signals a change in loading progres
        Args:
            value (int): if negative, interpreted as the nagative total number of files to load. If positive,
                interpreted as the number of files already processed.
        """
        if value < 0:
            self.progressbar_init_status.setMaximum(-value)
            self.progressbar_init_status.setValue(0)
            self.label_init_status.setText("Status: Loading student data...")
        elif value == 0:
            self.progressbar_init_status.setMaximum(100)
            self.progressbar_init_status.setValue(100)
        else:
            self.progressbar_init_status.setValue(value)
            QApplication.processEvents()
    
    def ui_set_autosave(self):
        """ Toggle autosave on/off """
        self.engine.do_autosave = self.checkbox_init_autosave.isChecked()
    
    def ui_set_autoimport(self):
        """ Toggle autoimport on/off """
        self.engine.do_autoimport = self.checkbox_init_autoimport.isChecked()
    
    def ui_menu_save(self):
        """
        Called from menu bar or Ctrl+S. Saves files for current defined comments, assigned comments and engine config.
        Also runs on exit.
        """
        self.engine.save_DCQ_file('ALL_WITH_CONTENTS')
        self.engine.save_ACQ_file('ALL_WITH_CONTENTS')
        self.engine.save_config()
    
    def eventFilter(self, source, event):
        """
        Bind keypress events for up/down arrow keys to cycle through students in current selection.
        """
        if self.engine.has_loaded_student_data():
            if event.type() == QtCore.QEvent.KeyPress:
                if event.key() == Qt.Key_Up:
                    self.ui_increment_student('next')
                elif event.key() == Qt.Key_Down:
                    self.ui_increment_student('prev')
        return super(FastGrade, self).eventFilter(source, event)
    
    @staticmethod
    def ui_show_about():
        """ Show a message box with info about the program and system. """
        text = """
                <p><b>FastGrade</b></p>
                <p><b>Version:\t</b> {0}</p>
                <p><b>Author:\t</b> {1}</p>
                <p><b>Copyright:\t</b>  &copy; 2017 {1}
                <p><b>You are using:</b></p>
                <p>Python {2} - Qt {3} - PyQt {4} on {5}</p>
                """.format(__version__, __author__, platform.python_version(),
                           QT_VERSION_STR, PYQT_VERSION_STR, platform.system())
        QMessageBox.question(QMessageBox(), 'About', text, QMessageBox.Close)
    
    def closeEvent(self, event):
        """ Called when the UI window is closed. DO NOT RENAME """
        if self.engine.do_autosave:
            if self.engine.verbose: print("Shutting down, saving settings...")
            self.ui_menu_save()
        else:
            choice = QMessageBox.question(QMessageBox(), 'FastGrade', "Save data before closing?",
                                               QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel, QMessageBox.Yes)
            if choice == QMessageBox.Yes:
                self.ui_menu_save()
            elif choice == QMessageBox.Cancel:
                event.ignore()
                return
            if self.engine.verbose: print("Shutting down...")


if __name__ == "__main__":
    app = QApplication(sys.argv) # arguments are ignored
    #app.setFont(QFont("Comic Sans", 12)) tinri font
    window = FastGrade(app)
    window.show()
    exitcode = app.exec_()
